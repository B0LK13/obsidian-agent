/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "node_modules/localforage/dist/localforage.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.localforage = f();
      }
    })(function() {
      var define2, module3, exports2;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof require == "function" && require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i = -1;
              while (++i < len) {
                oldQueue[i]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module4.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module4, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module4.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module4, exports3) {
        "use strict";
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i < parts.length; i += 1) {
              builder.append(parts[i]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i = 0; i < length2; i++) {
            arr[i] = bin.charCodeAt(i);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e) {
              e.preventDefault();
              e.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e) {
              e.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e) {
                e.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e) {
              var base64 = btoa(e.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i = 0; i < forages.length; i++) {
            var forage = forages[i];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j = 0; j < dbContext.forages.length; j++) {
            var forage = dbContext.forages[j];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k = 0; k < forages.length; k++) {
              var forage2 = forages[k];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var _forage = forages[i2];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j = 0; j < forages.length; j++) {
                    var _forage2 = forages[j];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i;
          var p = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i;
          for (i = 0; i < bytes.length; i += 3) {
            base64String += BASE_CHARS[bytes[i] >> 2];
            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64String += BASE_CHARS[bytes[i + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t, dbInfo, callback, errorCallback) {
          t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e) {
              return reject(e);
            }
            dbInfo.db.transaction(function(t) {
              createDbTable(t, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t2, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
          t.executeSql(sqlStatement, args, callback, function(t2, error) {
            if (error.code === error.SYNTAX_ERR) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
                if (!results.rows.length) {
                  createDbTable(t3, dbInfo, function() {
                    t3.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t2, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i = 0; i < length2; i++) {
                    var item = rows.item(i);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t) {
                    tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t2, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                  var keys2 = [];
                  for (var i = 0; i < results.rows.length; i++) {
                    keys2.push(results.rows.item(i).key);
                  }
                  resolve(keys2);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t) {
              t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
                var storeNames = [];
                for (var i = 0; i < results.rows.length; i++) {
                  storeNames.push(results.rows.item(i).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t2, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t2, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                    operations.push(dropTable(operationInfo.storeNames[i]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e) {
                    reject(e);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i = 0; i < length2; i++) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i = 0; i < length2; i++) {
              var itemKey = localStorage.key(i);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e) {
                    if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e);
                    }
                    reject(e);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x, y) {
          return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i = 0;
          while (i < len) {
            if (sameValue(array[i], searchElement)) {
              return true;
            }
            i++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i in options) {
                if (i === "storeName") {
                  options[i] = options[i].replace(/\W/g, "_");
                }
                if (i === "version" && typeof options[i] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i] = options[i];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                  var driverMethodName = driverMethods[i];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e) {
                reject(e);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i = 0, len = drivers.length; i < len; i++) {
              var driverName = drivers[i];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i = 0, len = LibraryMethods.length; i < len; i++) {
              callWhenReady(this, LibraryMethods[i]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module4.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AIChatNotesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/views/AIChatView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_AI_CHAT = "ai-chat-view";
var AIChatView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.contextNote = null;
    this.isProcessing = false;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_AI_CHAT;
  }
  getDisplayText() {
    return "AI Chat";
  }
  getIcon() {
    return "message-circle";
  }
  async onOpen() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("ai-chat-notes-root");
    const mainContainer = containerEl.createDiv({ cls: "ai-chat-container" });
    const header = mainContainer.createDiv({ cls: "ai-chat-header" });
    header.createEl("h3", { text: "AI Assistant", cls: "ai-chat-title" });
    const clearBtn = header.createEl("button", {
      text: "Clear",
      cls: "ai-clear-button"
    });
    clearBtn.addEventListener("click", () => this.clearChat());
    this.chatContainer = mainContainer.createDiv({ cls: "ai-chat-messages" });
    this.addWelcomeMessage();
    this.inputContainer = mainContainer.createDiv({ cls: "ai-chat-input-container" });
    this.createInputArea();
    await this.loadChatHistory();
  }
  async onClose() {
    await this.saveChatHistory();
  }
  addWelcomeMessage() {
    const welcomeDiv = this.chatContainer.createDiv({ cls: "ai-welcome-message" });
    welcomeDiv.innerHTML = `
			<div class="ai-welcome-icon">\u{1F916}</div>
			<h4>Welcome to AI Chat</h4>
			<p>I can help you with:</p>
			<ul>
				<li>Answering questions about your notes</li>
				<li>Summarizing content</li>
				<li>Generating ideas and writing assistance</li>
				<li>Finding connections between notes</li>
			</ul>
		`;
  }
  createInputArea() {
    const textarea = this.inputContainer.createEl("textarea", {
      cls: "ai-chat-input",
      placeholder: "Ask me anything... (Shift+Enter for new line)"
    });
    textarea.addEventListener("input", () => {
      textarea.style.height = "auto";
      textarea.style.height = Math.min(textarea.scrollHeight, 200) + "px";
    });
    textarea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage(textarea.value);
        textarea.value = "";
        textarea.style.height = "auto";
      }
    });
    const sendBtn = this.inputContainer.createEl("button", {
      cls: "ai-send-button",
      text: "\u27A4"
    });
    sendBtn.addEventListener("click", () => {
      this.sendMessage(textarea.value);
      textarea.value = "";
      textarea.style.height = "auto";
    });
    if (this.contextNote) {
      this.showContextIndicator();
    }
  }
  showContextIndicator() {
    var _a;
    const existingIndicator = this.inputContainer.querySelector(".ai-context-panel");
    if (existingIndicator)
      existingIndicator.remove();
    if (this.contextNote) {
      const indicator = this.inputContainer.createDiv({ cls: "ai-context-panel" });
      indicator.innerHTML = `
				<div class="context-title">\u{1F4C4} Context: ${this.contextNote.name}</div>
				<div class="context-actions">
					<button class="context-clear">Clear</button>
				</div>
			`;
      (_a = indicator.querySelector(".context-clear")) == null ? void 0 : _a.addEventListener("click", () => {
        this.contextNote = null;
        indicator.remove();
      });
    }
  }
  setContextNote(name, content) {
    this.contextNote = { name, content };
    this.showContextIndicator();
    new import_obsidian.Notice(`Context set to: ${name}`);
  }
  async sendMessage(content) {
    var _a;
    if (!content.trim() || this.isProcessing)
      return;
    const userMessage = {
      id: crypto.randomUUID(),
      role: "user",
      content: content.trim(),
      timestamp: Date.now()
    };
    this.messages.push(userMessage);
    await this.renderMessage(userMessage);
    this.showTypingIndicator();
    this.isProcessing = true;
    try {
      let contextPrompt = "";
      if (this.contextNote) {
        contextPrompt = `Context from note "${this.contextNote.name}":
${this.contextNote.content.substring(0, 4e3)}

`;
      }
      const relevantNotes = await this.plugin.searchService.findRelevantNotes(content);
      if (relevantNotes.length > 0) {
        contextPrompt += `
Relevant notes:
`;
        for (const note of relevantNotes.slice(0, this.plugin.settings.maxContextNotes)) {
          const noteContent = await this.app.vault.read(note);
          contextPrompt += `
--- ${note.basename} ---
${noteContent.substring(0, 1e3)}
`;
        }
      }
      const response = await this.plugin.aiService.generateResponse(
        contextPrompt + content,
        this.plugin.settings.defaultModel
      );
      const aiMessage = {
        id: crypto.randomUUID(),
        role: "assistant",
        content: response,
        timestamp: Date.now(),
        contextFile: (_a = this.contextNote) == null ? void 0 : _a.name
      };
      this.messages.push(aiMessage);
      await this.renderMessage(aiMessage);
    } catch (error) {
      console.error("AI Error:", error);
      const errorMessage = {
        id: crypto.randomUUID(),
        role: "assistant",
        content: `\u274C Error: ${error.message || "Failed to get AI response"}`,
        timestamp: Date.now()
      };
      this.messages.push(errorMessage);
      await this.renderMessage(errorMessage);
    } finally {
      this.hideTypingIndicator();
      this.isProcessing = false;
    }
  }
  async renderMessage(message) {
    const welcomeMsg = this.chatContainer.querySelector(".ai-welcome-message");
    if (welcomeMsg)
      welcomeMsg.remove();
    const bubble = this.chatContainer.createDiv({
      cls: `ai-message-bubble ${message.role}`
    });
    const content = bubble.createDiv({ cls: "message-content" });
    await import_obsidian.MarkdownRenderer.renderMarkdown(message.content, content, "", this);
    const timestamp = bubble.createDiv({ cls: "message-timestamp" });
    timestamp.textContent = new Date(message.timestamp).toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit"
    });
    if (message.role === "assistant") {
      const actions = bubble.createDiv({ cls: "message-actions" });
      const copyBtn = actions.createEl("button", {
        cls: "message-action-btn",
        text: "\u{1F4CB} Copy"
      });
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(message.content);
        new import_obsidian.Notice("Copied to clipboard");
      });
      const saveBtn = actions.createEl("button", {
        cls: "message-action-btn",
        text: "\u{1F4BE} Save to Note"
      });
      saveBtn.addEventListener("click", () => this.saveToNote(message.content));
    }
    this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
  }
  showTypingIndicator() {
    const indicator = this.chatContainer.createDiv({ cls: "ai-typing-indicator" });
    indicator.innerHTML = "<span></span><span></span><span></span>";
    this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
  }
  hideTypingIndicator() {
    const indicator = this.chatContainer.querySelector(".ai-typing-indicator");
    if (indicator)
      indicator.remove();
  }
  async saveToNote(content) {
    const fileName = `AI-Response-${Date.now()}.md`;
    const filePath = `AI-Chat/${fileName}`;
    const folder = this.app.vault.getAbstractFileByPath("AI-Chat");
    if (!folder) {
      await this.app.vault.createFolder("AI-Chat");
    }
    await this.app.vault.create(filePath, `# AI Response

${content}`);
    new import_obsidian.Notice(`Saved to ${filePath}`);
  }
  clearChat() {
    this.messages = [];
    this.chatContainer.empty();
    this.addWelcomeMessage();
    this.saveChatHistory();
  }
  async loadChatHistory() {
    if (!this.plugin.settings.storeChatHistory)
      return;
    const data = await this.plugin.dbManager.getChatHistory();
    if (data && data.length > 0) {
      this.messages = data;
      this.chatContainer.empty();
      for (const msg of this.messages) {
        await this.renderMessage(msg);
      }
    }
  }
  async saveChatHistory() {
    if (!this.plugin.settings.storeChatHistory)
      return;
    await this.plugin.dbManager.saveChatHistory(this.messages);
  }
};

// src/views/NoteBrowserView.ts
var import_obsidian2 = require("obsidian");
var VIEW_TYPE_NOTE_BROWSER = "note-browser-view";
var NoteBrowserView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFilter = "";
    this.expandedFolders = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_NOTE_BROWSER;
  }
  getDisplayText() {
    return "Note Browser";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("ai-chat-notes-root", "note-browser-container");
    const header = containerEl.createDiv({ cls: "note-browser-header" });
    header.createEl("h3", { text: "Notes", cls: "note-browser-title" });
    this.searchInput = header.createEl("input", {
      type: "text",
      placeholder: "Search notes...",
      cls: "note-browser-search"
    });
    this.searchInput.addEventListener("input", (e) => {
      this.currentFilter = e.target.value.toLowerCase();
      this.renderTree();
    });
    const newNoteBtn = header.createEl("button", {
      cls: "new-note-btn",
      text: "+ New Note"
    });
    newNoteBtn.addEventListener("click", () => this.createNewNote());
    this.treeContainer = containerEl.createDiv({ cls: "note-browser-tree" });
    await this.renderTree();
  }
  async onClose() {
  }
  async renderTree() {
    this.treeContainer.empty();
    const root = this.app.vault.getRoot();
    const tree = this.buildTree(root);
    for (const item of tree.children || []) {
      this.renderTreeItem(item, this.treeContainer, 0);
    }
  }
  buildTree(folder) {
    const children = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian2.TFolder) {
        const childTree = this.buildTree(child);
        if (this.shouldShowItem(childTree)) {
          children.push(childTree);
        }
      } else if (child instanceof import_obsidian2.TFile && child.extension === "md") {
        if (this.shouldShowItem({ file: child, isFolder: false })) {
          children.push({ file: child, isFolder: false });
        }
      }
    }
    children.sort((a, b) => {
      if (a.isFolder && !b.isFolder)
        return -1;
      if (!a.isFolder && b.isFolder)
        return 1;
      return a.file.name.localeCompare(b.file.name);
    });
    return {
      file: folder,
      isFolder: true,
      children,
      isExpanded: this.expandedFolders.has(folder.path)
    };
  }
  shouldShowItem(item) {
    if (!this.currentFilter)
      return true;
    const name = item.file.name.toLowerCase();
    if (name.includes(this.currentFilter))
      return true;
    if (item.isFolder && item.children) {
      return item.children.some((child) => this.shouldShowItem(child));
    }
    return false;
  }
  renderTreeItem(item, container, depth) {
    const itemEl = container.createDiv({ cls: "note-tree-item" });
    itemEl.style.paddingLeft = `${depth * 16}px`;
    if (item.isFolder) {
      const folderEl = itemEl.createDiv({ cls: "note-folder" });
      const expandIcon = folderEl.createSpan({
        cls: "expand-icon",
        text: item.isExpanded ? "\u25BC" : "\u25B6"
      });
      const folderIcon = folderEl.createSpan({
        cls: "folder-icon",
        text: "\u{1F4C1}"
      });
      const folderName = folderEl.createSpan({
        cls: "folder-name",
        text: item.file.name
      });
      folderEl.addEventListener("click", (e) => {
        e.stopPropagation();
        this.toggleFolder(item.file.path);
      });
      folderEl.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.showFolderContextMenu(e, item.file);
      });
      if (item.isExpanded && item.children) {
        const childrenContainer = container.createDiv({ cls: "note-children" });
        for (const child of item.children) {
          this.renderTreeItem(child, childrenContainer, depth + 1);
        }
      }
    } else {
      const file = item.file;
      const fileEl = itemEl.createDiv({ cls: "note-file" });
      const fileIcon = fileEl.createSpan({
        cls: "file-icon",
        text: "\u{1F4DD}"
      });
      const fileName = fileEl.createSpan({
        cls: "file-name",
        text: file.basename
      });
      fileEl.addEventListener("click", () => {
        this.app.workspace.openLinkText(file.path, "", true);
      });
      fileEl.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.showFileContextMenu(e, file);
      });
      fileEl.setAttribute("draggable", "true");
      fileEl.addEventListener("dragstart", (e) => {
        var _a;
        (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", file.path);
      });
    }
  }
  toggleFolder(path) {
    if (this.expandedFolders.has(path)) {
      this.expandedFolders.delete(path);
    } else {
      this.expandedFolders.add(path);
    }
    this.renderTree();
  }
  showFolderContextMenu(e, folder) {
    const menu = new import_obsidian2.Menu();
    menu.addItem((item) => {
      item.setTitle("New Note");
      item.setIcon("file-plus");
      item.onClick(() => this.createNewNoteInFolder(folder));
    });
    menu.addItem((item) => {
      item.setTitle("New Folder");
      item.setIcon("folder-plus");
      item.onClick(() => this.createNewFolder(folder));
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Collapse All");
      item.setIcon("fold-vertical");
      item.onClick(() => {
        this.expandedFolders.clear();
        this.renderTree();
      });
    });
    menu.showAtMouseEvent(e);
  }
  showFileContextMenu(e, file) {
    const menu = new import_obsidian2.Menu();
    menu.addItem((item) => {
      item.setTitle("Open");
      item.setIcon("file");
      item.onClick(() => {
        this.app.workspace.openLinkText(file.path, "", true);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Ask AI about this");
      item.setIcon("message-circle");
      item.onClick(async () => {
        await this.plugin.askAIAboutNote(file);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Add to Chat Context");
      item.setIcon("plus-circle");
      item.onClick(async () => {
        const content = await this.app.vault.read(file);
        this.plugin.activateChatView();
        const leaf = this.app.workspace.getLeavesOfType("ai-chat-view")[0];
        if (leaf && leaf.view) {
          leaf.view.setContextNote(file.name, content);
        }
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Copy Path");
      item.setIcon("copy");
      item.onClick(() => {
        navigator.clipboard.writeText(file.path);
        new import_obsidian2.Notice("Path copied to clipboard");
      });
    });
    menu.addItem((item) => {
      item.setTitle("Delete");
      item.setIcon("trash");
      item.onClick(async () => {
        await this.app.vault.delete(file);
        this.renderTree();
      });
    });
    menu.showAtMouseEvent(e);
  }
  async createNewNote() {
    const folder = this.app.fileManager.getNewFileParent("");
    await this.createNewNoteInFolder(folder);
  }
  async createNewNoteInFolder(folder) {
    const name = `Note-${Date.now()}`;
    const path = `${folder.path}/${name}.md`;
    const file = await this.app.vault.create(path, "# ");
    await this.app.workspace.openLinkText(file.path, "", true);
    this.renderTree();
  }
  async createNewFolder(parent) {
    const name = `Folder-${Date.now()}`;
    const path = `${parent.path}/${name}`;
    await this.app.vault.createFolder(path);
    this.expandedFolders.add(parent.path);
    this.renderTree();
  }
};

// src/views/HandwritingView.ts
var import_obsidian3 = require("obsidian");
var VIEW_TYPE_HANDWRITING = "handwriting-view";
var HandwritingView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.canvas = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_HANDWRITING;
  }
  getDisplayText() {
    return "Handwriting Canvas";
  }
  getIcon() {
    return "pen-tool";
  }
  async onOpen() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("handwriting-view");
    const header = containerEl.createDiv({ cls: "handwriting-header" });
    header.createEl("h3", { text: "\u{1F4DD} Handwriting Canvas" });
    const toolbar = containerEl.createDiv({ cls: "handwriting-toolbar" });
    const colors = this.plugin.api.handwriting.getPresetColors();
    const colorContainer = toolbar.createDiv({ cls: "toolbar-group" });
    colorContainer.createEl("span", { text: "Color:", cls: "toolbar-label" });
    colors.forEach((color) => {
      const colorBtn = colorContainer.createEl("button", {
        cls: "color-btn",
        attr: { style: `background-color: ${color}` }
      });
      colorBtn.addEventListener("click", () => {
        this.plugin.api.handwriting.setStrokeColor(color);
        this.updateActiveColor(colorBtn);
      });
    });
    const sizeContainer = toolbar.createDiv({ cls: "toolbar-group" });
    sizeContainer.createEl("span", { text: "Size:", cls: "toolbar-label" });
    const sizeSlider = sizeContainer.createEl("input", {
      type: "range",
      cls: "brush-size-slider",
      attr: { min: "1", max: "20", value: "3" }
    });
    sizeSlider.addEventListener("input", (e) => {
      const size = parseInt(e.target.value);
      this.plugin.api.handwriting.setStrokeWidth(size);
    });
    const toolsContainer = toolbar.createDiv({ cls: "toolbar-group" });
    const eraserBtn = toolsContainer.createEl("button", {
      cls: "tool-btn",
      text: "\u{1F9F9} Eraser"
    });
    eraserBtn.addEventListener("click", () => {
      const isEraser = this.plugin.api.handwriting.toggleEraser();
      eraserBtn.toggleClass("active", isEraser);
    });
    const undoBtn = toolsContainer.createEl("button", {
      cls: "tool-btn",
      text: "\u21A9\uFE0F Undo"
    });
    undoBtn.addEventListener("click", () => {
      this.plugin.api.handwriting.undo();
    });
    const clearBtn = toolsContainer.createEl("button", {
      cls: "tool-btn danger",
      text: "\u{1F5D1}\uFE0F Clear"
    });
    clearBtn.addEventListener("click", () => {
      if (confirm("Clear the canvas?")) {
        this.plugin.api.handwriting.clear();
      }
    });
    const canvasContainer = containerEl.createDiv({ cls: "canvas-container" });
    this.canvas = canvasContainer.createEl("canvas", {
      cls: "handwriting-canvas"
    });
    const containerWidth = canvasContainer.clientWidth || 800;
    const containerHeight = canvasContainer.clientHeight || 600;
    this.plugin.api.handwriting.initializeCanvas(this.canvas, containerWidth - 40, containerHeight - 40);
    const footer = containerEl.createDiv({ cls: "handwriting-footer" });
    const saveBtn = footer.createEl("button", {
      cls: "action-btn primary",
      text: "\u{1F4BE} Save as Note"
    });
    saveBtn.addEventListener("click", () => this.saveAsNote());
    const downloadBtn = footer.createEl("button", {
      cls: "action-btn",
      text: "\u{1F4E5} Download Image"
    });
    downloadBtn.addEventListener("click", () => {
      this.plugin.api.handwriting.downloadAsImage();
    });
    const exportBtn = footer.createEl("button", {
      cls: "action-btn",
      text: "\u{1F4E4} Export Strokes"
    });
    exportBtn.addEventListener("click", () => this.exportStrokes());
  }
  updateActiveColor(activeBtn) {
    const container = this.containerEl.querySelector(".toolbar-group");
    container == null ? void 0 : container.querySelectorAll(".color-btn").forEach((btn) => {
      btn.removeClass("active");
    });
    activeBtn.addClass("active");
  }
  async saveAsNote() {
    try {
      const content = await this.plugin.api.handwriting.convertToNote();
      const timestamp = Date.now();
      const fileName = `Handwriting-${timestamp}`;
      const filePath = `AI-Chat/${fileName}.md`;
      const folder = this.app.vault.getAbstractFileByPath("AI-Chat");
      if (!folder) {
        await this.app.vault.createFolder("AI-Chat");
      }
      await this.app.vault.create(filePath, content);
      new import_obsidian3.Notice(`Saved to ${filePath}`);
    } catch (error) {
      console.error("Failed to save note:", error);
      new import_obsidian3.Notice("Failed to save note");
    }
  }
  exportStrokes() {
    const json = this.plugin.api.handwriting.exportStrokes();
    if (json) {
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `handwriting-strokes-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      new import_obsidian3.Notice("Strokes exported");
    }
  }
  async onClose() {
  }
};

// src/views/KnowledgeGraphView.ts
var import_obsidian4 = require("obsidian");
var VIEW_TYPE_KNOWLEDGE_GRAPH = "knowledge-graph-view";
var KnowledgeGraphView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.canvas = null;
    this.ctx = null;
    this.animationId = null;
    // View state
    this.zoom = 1;
    this.panX = 0;
    this.panY = 0;
    this.isDragging = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    this.hoveredNode = null;
    this.selectedNode = null;
    // Filter state
    this.showNotes = true;
    this.showTags = true;
    this.showConcepts = true;
    this.minConnections = 0;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_KNOWLEDGE_GRAPH;
  }
  getDisplayText() {
    return "Knowledge Graph";
  }
  getIcon() {
    return "git-branch";
  }
  async onOpen() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("knowledge-graph-view");
    const header = containerEl.createDiv({ cls: "graph-header" });
    header.createEl("h3", { text: "\u{1F578}\uFE0F Knowledge Graph" });
    const toolbar = containerEl.createDiv({ cls: "graph-toolbar" });
    const buildBtn = toolbar.createEl("button", {
      cls: "graph-btn primary",
      text: "\u{1F504} Build Graph"
    });
    buildBtn.addEventListener("click", () => this.buildGraph());
    const layoutBtn = toolbar.createEl("button", {
      cls: "graph-btn",
      text: "\u{1F4D0} Auto Layout"
    });
    layoutBtn.addEventListener("click", () => this.autoLayout());
    const filterContainer = toolbar.createDiv({ cls: "filter-container" });
    const notesToggle = this.createToggle(filterContainer, "Notes", this.showNotes, (v) => {
      this.showNotes = v;
      this.render();
    });
    const tagsToggle = this.createToggle(filterContainer, "Tags", this.showTags, (v) => {
      this.showTags = v;
      this.render();
    });
    const conceptsToggle = this.createToggle(filterContainer, "Concepts", this.showConcepts, (v) => {
      this.showConcepts = v;
      this.render();
    });
    const statsContainer = containerEl.createDiv({ cls: "graph-stats" });
    statsContainer.id = "graph-stats";
    const canvasContainer = containerEl.createDiv({ cls: "graph-canvas-container" });
    this.canvas = canvasContainer.createEl("canvas", {
      cls: "graph-canvas"
    });
    const rect = canvasContainer.getBoundingClientRect();
    this.canvas.width = rect.width || 800;
    this.canvas.height = rect.height || 600;
    this.ctx = this.canvas.getContext("2d");
    if (!this.ctx) {
      new import_obsidian4.Notice("Failed to initialize canvas");
      return;
    }
    this.setupInteractions();
    await this.buildGraph();
  }
  createToggle(container, label, initialValue, onChange) {
    const wrapper = container.createDiv({ cls: "toggle-wrapper" });
    wrapper.createEl("span", { text: label, cls: "toggle-label" });
    const checkbox = wrapper.createEl("input", {
      type: "checkbox",
      cls: "toggle-checkbox"
    });
    checkbox.checked = initialValue;
    checkbox.addEventListener("change", () => onChange(checkbox.checked));
    return checkbox;
  }
  setupInteractions() {
    if (!this.canvas)
      return;
    this.canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      this.zoom = Math.max(0.1, Math.min(5, this.zoom * delta));
      this.render();
    });
    this.canvas.addEventListener("mousedown", (e) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const clickedNode = this.getNodeAt(x, y);
      if (clickedNode) {
        this.selectedNode = clickedNode;
        if (e.button === 2) {
          this.showNodeContextMenu(clickedNode, e.clientX, e.clientY);
        } else {
          this.openNode(clickedNode);
        }
        this.render();
        return;
      }
      this.isDragging = true;
      this.lastMouseX = e.clientX;
      this.lastMouseY = e.clientY;
    });
    this.canvas.addEventListener("mousemove", (e) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (this.isDragging) {
        const dx = e.clientX - this.lastMouseX;
        const dy = e.clientY - this.lastMouseY;
        this.panX += dx;
        this.panY += dy;
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        this.render();
      } else {
        const hovered = this.getNodeAt(x, y);
        if (hovered !== this.hoveredNode) {
          this.hoveredNode = hovered;
          this.canvas.style.cursor = hovered ? "pointer" : "default";
          this.render();
        }
      }
    });
    window.addEventListener("mouseup", () => {
      this.isDragging = false;
    });
    this.canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      this.showCanvasContextMenu(e.clientX, e.clientY);
    });
  }
  getNodeAt(x, y) {
    const graph = this.plugin.api.graph.graph;
    const clickRadius = 15;
    for (const node of graph.nodes) {
      if (!this.shouldShowNode(node))
        continue;
      const screenX = (node.x || 0) * this.zoom + this.panX;
      const screenY = (node.y || 0) * this.zoom + this.panY;
      const dx = x - screenX;
      const dy = y - screenY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance <= (node.size || 10) + clickRadius) {
        return node;
      }
    }
    return null;
  }
  shouldShowNode(node) {
    if (node.type === "note" && !this.showNotes)
      return false;
    if (node.type === "tag" && !this.showTags)
      return false;
    if (node.type === "concept" && !this.showConcepts)
      return false;
    if (this.minConnections > 0) {
      const connectionCount = this.plugin.api.graph.graph.edges.filter(
        (e) => e.source === node.id || e.target === node.id
      ).length;
      if (connectionCount < this.minConnections)
        return false;
    }
    return true;
  }
  openNode(node) {
    var _a;
    if (node.type === "note" && ((_a = node.metadata) == null ? void 0 : _a.path)) {
      this.app.workspace.openLinkText(node.metadata.path, "", true);
    }
  }
  showNodeContextMenu(node, x, y) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((item) => {
      item.setTitle("Open Note");
      item.setIcon("file");
      item.onClick(() => this.openNode(node));
    });
    menu.addItem((item) => {
      item.setTitle("Find Connections");
      item.setIcon("link");
      item.onClick(() => this.highlightConnections(node));
    });
    menu.addItem((item) => {
      item.setTitle("Find Path From...");
      item.setIcon("git-commit");
      item.onClick(() => this.startPathFinding(node));
    });
    menu.showAtPosition({ x, y });
  }
  showCanvasContextMenu(x, y) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((item) => {
      item.setTitle("Reset View");
      item.setIcon("maximize");
      item.onClick(() => {
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.render();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Export Graph");
      item.setIcon("download");
      item.onClick(() => this.exportGraph());
    });
    menu.showAtPosition({ x, y });
  }
  highlightConnections(node) {
    const connected = this.plugin.api.graph.getConnectedNodes(node.id);
    new import_obsidian4.Notice(`Found ${connected.length} connected nodes`);
  }
  startPathFinding(fromNode) {
    new import_obsidian4.Notice("Select target node to find path...");
  }
  async buildGraph() {
    new import_obsidian4.Notice("Building knowledge graph...");
    await this.plugin.api.graph.buildGraph();
    await this.plugin.api.graph.calculateLayout(100);
    this.updateStats();
    this.render();
    new import_obsidian4.Notice("Graph built successfully!");
  }
  autoLayout() {
    this.plugin.api.graph.calculateLayout(50);
    this.render();
    new import_obsidian4.Notice("Layout updated");
  }
  updateStats() {
    const stats = this.plugin.api.graph.calculateGraphStats();
    const statsEl = this.containerEl.querySelector("#graph-stats");
    if (statsEl) {
      statsEl.innerHTML = `
				<span>\u{1F4CA} Nodes: ${stats.totalNodes}</span>
				<span>\u{1F517} Edges: ${stats.totalEdges}</span>
				<span>\u{1F4C8} Avg Connect: ${stats.avgConnectivity}</span>
				<span>\u{1F50C} Isolated: ${stats.isolatedNodes}</span>
			`;
    }
  }
  render() {
    if (!this.ctx || !this.canvas)
      return;
    const ctx = this.ctx;
    const width = this.canvas.width;
    const height = this.canvas.height;
    ctx.fillStyle = getComputedStyle(this.containerEl).getPropertyValue("--background-primary") || "#ffffff";
    ctx.fillRect(0, 0, width, height);
    ctx.save();
    const graph = this.plugin.api.graph.graph;
    ctx.strokeStyle = getComputedStyle(this.containerEl).getPropertyValue("--text-muted") || "#999999";
    ctx.lineWidth = 1;
    graph.edges.forEach((edge) => {
      const source = graph.nodes.find((n) => n.id === edge.source);
      const target = graph.nodes.find((n) => n.id === edge.target);
      if (source && target && this.shouldShowNode(source) && this.shouldShowNode(target)) {
        const x1 = (source.x || 0) * this.zoom + this.panX;
        const y1 = (source.y || 0) * this.zoom + this.panY;
        const x2 = (target.x || 0) * this.zoom + this.panX;
        const y2 = (target.y || 0) * this.zoom + this.panY;
        switch (edge.type) {
          case "link":
            ctx.strokeStyle = "#667eea";
            break;
          case "tag":
            ctx.strokeStyle = "#10b981";
            break;
          case "reference":
            ctx.strokeStyle = "#f59e0b";
            break;
          default:
            ctx.strokeStyle = "#999999";
        }
        ctx.globalAlpha = edge.weight;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    });
    graph.nodes.forEach((node) => {
      if (!this.shouldShowNode(node))
        return;
      const x = (node.x || 0) * this.zoom + this.panX;
      const y = (node.y || 0) * this.zoom + this.panY;
      const size = (node.size || 10) * this.zoom;
      ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fillStyle = node.color;
      ctx.fill();
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      if (node === this.selectedNode) {
        ctx.strokeStyle = "#ff6b6b";
        ctx.lineWidth = 3;
        ctx.stroke();
      } else if (node === this.hoveredNode) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      if (this.zoom > 0.5) {
        ctx.fillStyle = getComputedStyle(this.containerEl).getPropertyValue("--text-normal") || "#000000";
        ctx.font = `${12 * this.zoom}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const label = node.label.length > 20 ? node.label.substring(0, 20) + "..." : node.label;
        ctx.fillText(label, x, y + size + 15 * this.zoom);
      }
    });
    ctx.restore();
  }
  exportGraph() {
    const json = this.plugin.api.graph.exportGraph();
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `knowledge-graph-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian4.Notice("Graph exported");
  }
  async onClose() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
};

// src/services/AIService.ts
var import_obsidian5 = require("obsidian");
var DEFAULT_EMBEDDING_DIMENSION = 384;
var DEFAULT_TIMEOUT_MS = 3e4;
var DEFAULT_RETRIES = 3;
var DEFAULT_MODELS = {
  openai: "gpt-4",
  anthropic: "claude-3-sonnet-20240229",
  ollama: "llama3.2",
  openaiEmbedding: "text-embedding-3-small",
  ollamaEmbedding: "nomic-embed-text"
};
function isRetryableError(error) {
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    if (message.includes("network") || message.includes("timeout") || message.includes("econnreset")) {
      return true;
    }
  }
  if (typeof error === "object" && error !== null && "status" in error) {
    const status = error.status;
    return status === 0 || status === 429 || status >= 500 && status < 600;
  }
  return false;
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function requestWithRetry(params, options = {}) {
  var _a, _b, _c;
  const timeout = (_a = options.timeout) != null ? _a : DEFAULT_TIMEOUT_MS;
  const maxRetries = (_b = options.retries) != null ? _b : DEFAULT_RETRIES;
  const operation = (_c = options.operation) != null ? _c : "API request";
  let lastError;
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error(operation + " timed out after " + timeout + "ms")), timeout);
      });
      const response = await Promise.race([(0, import_obsidian5.requestUrl)(params), timeoutPromise]);
      return response;
    } catch (error) {
      lastError = error;
      if (!isRetryableError(error))
        throw error;
      if (attempt === maxRetries - 1)
        break;
      const backoffMs = Math.min(1e3 * Math.pow(2, attempt), 1e4);
      console.log(operation + " failed (attempt " + (attempt + 1) + "/" + maxRetries + "), retrying in " + backoffMs + "ms...");
      await delay(backoffMs);
    }
  }
  throw lastError;
}
var AIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async generateResponse(prompt, model) {
    switch (this.settings.aiProvider) {
      case "openai":
        return this.callOpenAI(prompt, model);
      case "anthropic":
        return this.callAnthropic(prompt, model);
      case "ollama":
        return this.callOllama(prompt, model);
      case "local":
        return this.callLocalModel(prompt, model);
      default:
        throw new Error("Unknown AI provider");
    }
  }
  async callOpenAI(prompt, model) {
    if (!this.settings.openaiApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    const response = await requestWithRetry({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": "Bearer " + this.settings.openaiApiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: model || this.settings.defaultModel || DEFAULT_MODELS.openai,
        messages: [{ role: "user", content: prompt }],
        temperature: this.settings.temperature,
        max_tokens: this.settings.maxTokens
      })
    }, { operation: "OpenAI chat completion" });
    const data = response.json;
    if (data.error) {
      throw new Error(data.error.message);
    }
    return data.choices[0].message.content;
  }
  async callAnthropic(prompt, model) {
    if (!this.settings.anthropicApiKey) {
      throw new Error("Anthropic API key not configured");
    }
    const response = await requestWithRetry({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "x-api-key": this.settings.anthropicApiKey,
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: model || this.settings.defaultModel || DEFAULT_MODELS.anthropic,
        max_tokens: this.settings.maxTokens,
        temperature: this.settings.temperature,
        messages: [{ role: "user", content: prompt }]
      })
    }, { operation: "Anthropic messages" });
    const data = response.json;
    if (data.error) {
      throw new Error(data.error.message);
    }
    return data.content[0].text;
  }
  async callOllama(prompt, model) {
    const ollamaUrl = this.settings.ollamaUrl || "http://localhost:11434";
    try {
      const response = await requestWithRetry({
        url: ollamaUrl + "/api/generate",
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: model || this.settings.defaultModel || DEFAULT_MODELS.ollama,
          prompt,
          stream: false,
          options: {
            temperature: this.settings.temperature,
            num_predict: this.settings.maxTokens
          }
        })
      }, { timeout: 6e4, operation: "Ollama generate" });
      const data = response.json;
      if (data.error)
        throw new Error(data.error);
      return data.response;
    } catch (error) {
      if (error instanceof Error && error.message.includes("timed out")) {
        throw new Error("Ollama request timed out. The model might be loading or the server is slow.");
      }
      if (typeof error === "object" && error !== null && "status" in error && error.status === 0) {
        throw new Error("Cannot connect to Ollama. Make sure Ollama is running on " + ollamaUrl);
      }
      throw error;
    }
  }
  async callLocalModel(prompt, model) {
    throw new Error("Local model not yet implemented. Please use Ollama for local AI.");
  }
  async generateEmbedding(text) {
    if (this.settings.aiProvider === "ollama") {
      return this.generateOllamaEmbedding(text);
    } else if (this.settings.aiProvider === "openai") {
      return this.generateOpenAIEmbedding(text);
    }
    return new Array(DEFAULT_EMBEDDING_DIMENSION).fill(0);
  }
  async generateOllamaEmbedding(text) {
    const ollamaUrl = this.settings.ollamaUrl || "http://localhost:11434";
    const model = this.settings.embeddingModel || DEFAULT_MODELS.ollamaEmbedding;
    const response = await requestWithRetry({
      url: ollamaUrl + "/api/embeddings",
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model, prompt: text })
    }, { timeout: 3e4, operation: "Ollama embedding" });
    const data = response.json;
    return data.embedding;
  }
  async generateOpenAIEmbedding(text) {
    if (!this.settings.openaiApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    const response = await requestWithRetry({
      url: "https://api.openai.com/v1/embeddings",
      method: "POST",
      headers: {
        "Authorization": "Bearer " + this.settings.openaiApiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.settings.embeddingModel || DEFAULT_MODELS.openaiEmbedding,
        input: text
      })
    }, { operation: "OpenAI embedding" });
    const data = response.json;
    return data.data[0].embedding;
  }
  async summarizeText(text, maxLength = 200) {
    const prompt = "Summarize the following text in " + maxLength + " characters or less:\n\n" + text;
    return this.generateResponse(prompt);
  }
  async extractKeyPoints(text) {
    const prompt = "Extract the key points from the following text. Format each point starting with a dash (-):\n\n" + text;
    const response = await this.generateResponse(prompt);
    return response.split("\n").filter((line) => line.trim().startsWith("-") || line.trim().startsWith("\u2022"));
  }
  async suggestTags(content, existingTags) {
    const prompt = "Suggest relevant tags for the following content. Return only the tags separated by commas. Existing tags: " + existingTags.join(", ") + "\n\nContent:\n" + content;
    const response = await this.generateResponse(prompt);
    return response.split(",").map((tag) => tag.trim()).filter((tag) => tag);
  }
  async answerQuestion(question, context) {
    const prompt = "Based on the following context, answer the question.\n\nContext:\n" + context + "\n\nQuestion: " + question;
    return this.generateResponse(prompt);
  }
};

// src/services/SearchService.ts
var import_obsidian6 = require("obsidian");
var SearchService = class {
  constructor(plugin) {
    this.embeddings = /* @__PURE__ */ new Map();
    this.isSyncing = false;
    this.plugin = plugin;
    this.vault = plugin.app.vault;
    this.loadEmbeddings();
  }
  async loadEmbeddings() {
    const data = await this.plugin.dbManager.getEmbeddings();
    for (const item of data) {
      this.embeddings.set(item.path, item);
    }
  }
  async syncEmbeddings() {
    if (this.isSyncing)
      return;
    this.isSyncing = true;
    try {
      const files = this.vault.getMarkdownFiles();
      for (const file of files) {
        const existing = this.embeddings.get(file.path);
        if (!existing || existing.lastModified !== file.stat.mtime) {
          const content = await this.vault.read(file);
          const embedding = await this.plugin.aiService.generateEmbedding(content);
          const noteEmbedding = {
            path: file.path,
            embedding,
            lastModified: file.stat.mtime
          };
          this.embeddings.set(file.path, noteEmbedding);
          await this.plugin.dbManager.saveEmbedding(noteEmbedding);
        }
      }
      for (const [path, _] of this.embeddings) {
        const file = this.vault.getAbstractFileByPath(path);
        if (!file) {
          this.embeddings.delete(path);
          await this.plugin.dbManager.deleteEmbedding(path);
        }
      }
    } finally {
      this.isSyncing = false;
    }
  }
  async semanticSearch(query) {
    if (!this.plugin.settings.enableSemanticSearch) {
      return this.basicSearch(query);
    }
    const queryEmbedding = await this.plugin.aiService.generateEmbedding(query);
    const similarities = [];
    for (const [path, noteEmbedding] of this.embeddings) {
      const file = this.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian6.TFile) {
        const similarity = this.cosineSimilarity(queryEmbedding, noteEmbedding.embedding);
        similarities.push({ file, similarity });
      }
    }
    similarities.sort((a, b) => b.similarity - a.similarity);
    return similarities.filter((s) => s.similarity > 0.7).map((s) => s.file);
  }
  basicSearch(query) {
    const files = this.vault.getMarkdownFiles();
    const lowerQuery = query.toLowerCase();
    return files.filter((file) => {
      return file.basename.toLowerCase().includes(lowerQuery) || file.path.toLowerCase().includes(lowerQuery);
    });
  }
  async findRelevantNotes(query, limit = 5) {
    return this.semanticSearch(query).then((files) => files.slice(0, limit));
  }
  cosineSimilarity(a, b) {
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
  async searchWithFilters(query, filters) {
    let results = await this.semanticSearch(query);
    if (filters.folder) {
      results = results.filter((file) => file.path.startsWith(filters.folder));
    }
    if (filters.dateRange) {
      results = results.filter((file) => {
        const mtime = new Date(file.stat.mtime);
        return mtime >= filters.dateRange.start && mtime <= filters.dateRange.end;
      });
    }
    if (filters.tags && filters.tags.length > 0) {
      const filteredResults = [];
      for (const file of results) {
        const content = await this.vault.read(file);
        const hasTag = filters.tags.some(
          (tag) => content.includes(`#${tag}`) || content.includes(`tag: ${tag}`)
        );
        if (hasTag) {
          filteredResults.push(file);
        }
      }
      results = filteredResults;
    }
    return results;
  }
  async getRelatedNotes(file, limit = 5) {
    const fileEmbedding = this.embeddings.get(file.path);
    if (!fileEmbedding) {
      const content = await this.vault.read(file);
      const embedding = await this.plugin.aiService.generateEmbedding(content);
      const noteEmbedding = {
        path: file.path,
        embedding,
        lastModified: file.stat.mtime
      };
      this.embeddings.set(file.path, noteEmbedding);
      await this.plugin.dbManager.saveEmbedding(noteEmbedding);
      return this.getRelatedNotes(file, limit);
    }
    const similarities = [];
    for (const [path, noteEmbedding] of this.embeddings) {
      if (path === file.path)
        continue;
      const otherFile = this.vault.getAbstractFileByPath(path);
      if (otherFile instanceof import_obsidian6.TFile) {
        const similarity = this.cosineSimilarity(
          fileEmbedding.embedding,
          noteEmbedding.embedding
        );
        similarities.push({ file: otherFile, similarity });
      }
    }
    similarities.sort((a, b) => b.similarity - a.similarity);
    return similarities.filter((s) => s.similarity > 0.75).slice(0, limit).map((s) => s.file);
  }
};

// src/services/ChatService.ts
var import_obsidian7 = require("obsidian");
var ChatService = class {
  constructor(plugin) {
    this.currentSession = null;
    this.sessions = [];
    this.plugin = plugin;
    this.loadSessions();
  }
  async loadSessions() {
    this.sessions = await this.plugin.dbManager.getChatSessions();
  }
  createSession(title) {
    const session = {
      id: crypto.randomUUID(),
      title: title || "New Chat",
      messages: [],
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    this.sessions.unshift(session);
    this.currentSession = session;
    this.saveSession(session);
    return session;
  }
  async saveSession(session) {
    await this.plugin.dbManager.saveChatSession(session);
  }
  async deleteSession(sessionId) {
    var _a;
    this.sessions = this.sessions.filter((s) => s.id !== sessionId);
    await this.plugin.dbManager.deleteChatSession(sessionId);
    if (((_a = this.currentSession) == null ? void 0 : _a.id) === sessionId) {
      this.currentSession = null;
    }
  }
  getSession(sessionId) {
    return this.sessions.find((s) => s.id === sessionId);
  }
  setCurrentSession(session) {
    this.currentSession = session;
  }
  async addMessage(sessionId, message) {
    const session = this.getSession(sessionId);
    if (!session)
      return;
    session.messages.push(message);
    session.updatedAt = Date.now();
    await this.saveSession(session);
  }
  async convertToNote(sessionId) {
    const session = sessionId ? this.getSession(sessionId) : this.currentSession;
    if (!session || session.messages.length === 0) {
      new import_obsidian7.Notice("No chat to convert");
      return null;
    }
    let content = `# ${session.title}

`;
    content += `*Created: ${new Date(session.createdAt).toLocaleString()}*

`;
    content += `---

`;
    for (const message of session.messages) {
      const role = message.role === "user" ? "**You**" : "**AI**";
      content += `${role} (${new Date(message.timestamp).toLocaleTimeString()}):
`;
      content += `${message.content}

`;
    }
    const fileName = `Chat-${session.title.replace(/[^a-zA-Z0-9]/g, "-")}-${Date.now()}.md`;
    const filePath = `AI-Chat/${fileName}`;
    const folder = this.plugin.app.vault.getAbstractFileByPath("AI-Chat");
    if (!folder) {
      await this.plugin.app.vault.createFolder("AI-Chat");
    }
    const file = await this.plugin.app.vault.create(filePath, content);
    new import_obsidian7.Notice("Chat converted to note");
    return file;
  }
  async generateSessionTitle(sessionId) {
    const session = this.getSession(sessionId);
    if (!session || session.messages.length === 0) {
      return "New Chat";
    }
    const firstMessage = session.messages.find((m) => m.role === "user");
    if (!firstMessage)
      return "New Chat";
    const prompt = `Based on this message, generate a short (3-5 words) chat title:

${firstMessage.content.substring(0, 200)}`;
    try {
      const title = await this.plugin.aiService.generateResponse(prompt);
      return title.trim().replace(/["']/g, "");
    } catch (error) {
      return firstMessage.content.substring(0, 30).trim() + "...";
    }
  }
  async autoGenerateTitle(sessionId) {
    const title = await this.generateSessionTitle(sessionId);
    const session = this.getSession(sessionId);
    if (session) {
      session.title = title;
      await this.saveSession(session);
    }
  }
  searchSessions(query) {
    const lowerQuery = query.toLowerCase();
    return this.sessions.filter((session) => {
      if (session.title.toLowerCase().includes(lowerQuery))
        return true;
      return session.messages.some(
        (m) => m.content.toLowerCase().includes(lowerQuery)
      );
    });
  }
  exportSession(sessionId) {
    const session = this.getSession(sessionId);
    if (!session)
      return "";
    return JSON.stringify(session, null, 2);
  }
  importSession(json) {
    try {
      const session = JSON.parse(json);
      session.id = crypto.randomUUID();
      session.createdAt = Date.now();
      session.updatedAt = Date.now();
      this.sessions.unshift(session);
      this.saveSession(session);
      return session;
    } catch (error) {
      new import_obsidian7.Notice("Failed to import chat session");
      return null;
    }
  }
};

// src/db/DatabaseManager.ts
var DatabaseManager = class {
  constructor(plugin) {
    this.db = null;
    this.isInitialized = false;
    this.plugin = plugin;
  }
  async initialize() {
    if (this.isInitialized)
      return;
    try {
      const localforageModule = await Promise.resolve().then(() => __toESM(require_localforage()));
      const localforage = localforageModule.default || localforageModule;
      this.db = localforage.createInstance({
        name: "AIChatNotes",
        version: 1,
        storeName: "data",
        description: "AI Chat & Notes database"
      });
      this.isInitialized = true;
    } catch (error) {
      console.error("Failed to initialize database:", error);
      this.db = {
        data: /* @__PURE__ */ new Map(),
        async getItem(key) {
          return this.data.get(key);
        },
        async setItem(key, value) {
          this.data.set(key, value);
        },
        async removeItem(key) {
          this.data.delete(key);
        },
        async keys() {
          return Array.from(this.data.keys());
        }
      };
      this.isInitialized = true;
    }
  }
  async close() {
    this.isInitialized = false;
  }
  // Chat History Methods
  async getChatHistory() {
    if (!this.isInitialized)
      return [];
    const history = await this.db.getItem("chatHistory");
    return history || [];
  }
  async saveChatHistory(messages) {
    if (!this.isInitialized)
      return;
    await this.db.setItem("chatHistory", messages);
  }
  async clearChatHistory() {
    if (!this.isInitialized)
      return;
    await this.db.removeItem("chatHistory");
  }
  // Embeddings Methods
  async getEmbeddings() {
    if (!this.isInitialized)
      return [];
    const embeddings = await this.db.getItem("embeddings");
    return embeddings || [];
  }
  async saveEmbedding(embedding) {
    if (!this.isInitialized)
      return;
    const embeddings = await this.getEmbeddings();
    const index = embeddings.findIndex((e) => e.path === embedding.path);
    if (index >= 0) {
      embeddings[index] = embedding;
    } else {
      embeddings.push(embedding);
    }
    await this.db.setItem("embeddings", embeddings);
  }
  async deleteEmbedding(path) {
    if (!this.isInitialized)
      return;
    const embeddings = await this.getEmbeddings();
    const filtered = embeddings.filter((e) => e.path !== path);
    await this.db.setItem("embeddings", filtered);
  }
  async clearEmbeddings() {
    if (!this.isInitialized)
      return;
    await this.db.removeItem("embeddings");
  }
  // Chat Sessions Methods
  async getChatSessions() {
    if (!this.isInitialized)
      return [];
    const sessions = await this.db.getItem("chatSessions");
    return sessions || [];
  }
  async saveChatSession(session) {
    if (!this.isInitialized)
      return;
    const sessions = await this.getChatSessions();
    const index = sessions.findIndex((s) => s.id === session.id);
    if (index >= 0) {
      sessions[index] = session;
    } else {
      sessions.push(session);
    }
    await this.db.setItem("chatSessions", sessions);
  }
  async deleteChatSession(sessionId) {
    if (!this.isInitialized)
      return;
    const sessions = await this.getChatSessions();
    const filtered = sessions.filter((s) => s.id !== sessionId);
    await this.db.setItem("chatSessions", filtered);
  }
  // Settings Methods (for sync across devices)
  async getSyncedSettings() {
    if (!this.isInitialized)
      return null;
    return await this.db.getItem("syncedSettings");
  }
  async saveSyncedSettings(settings) {
    if (!this.isInitialized)
      return;
    await this.db.setItem("syncedSettings", settings);
  }
  // General Storage Methods
  async getItem(key) {
    if (!this.isInitialized)
      return null;
    return await this.db.getItem(key);
  }
  async setItem(key, value) {
    if (!this.isInitialized)
      return;
    await this.db.setItem(key, value);
  }
  async removeItem(key) {
    if (!this.isInitialized)
      return;
    await this.db.removeItem(key);
  }
  // Export/Import Methods
  async exportAllData() {
    const data = {
      chatHistory: await this.getChatHistory(),
      embeddings: await this.getEmbeddings(),
      chatSessions: await this.getChatSessions(),
      exportDate: new Date().toISOString(),
      version: "1.0.0"
    };
    return JSON.stringify(data, null, 2);
  }
  async importAllData(json) {
    try {
      const data = JSON.parse(json);
      if (data.chatHistory) {
        await this.saveChatHistory(data.chatHistory);
      }
      if (data.embeddings) {
        await this.db.setItem("embeddings", data.embeddings);
      }
      if (data.chatSessions) {
        await this.db.setItem("chatSessions", data.chatSessions);
      }
      return true;
    } catch (error) {
      console.error("Failed to import data:", error);
      return false;
    }
  }
  // Stats Methods
  async getStats() {
    const history = await this.getChatHistory();
    const sessions = await this.getChatSessions();
    const embeddings = await this.getEmbeddings();
    const data = {
      history,
      sessions,
      embeddings
    };
    const json = JSON.stringify(data);
    const sizeInKB = (json.length / 1024).toFixed(2);
    return {
      messageCount: history.length,
      sessionCount: sessions.length,
      embeddingCount: embeddings.length,
      storageSize: `${sizeInKB} KB`
    };
  }
  // Maintenance Methods
  async cleanup() {
    const embeddings = await this.getEmbeddings();
    const vault = this.plugin.app.vault;
    const validEmbeddings = embeddings.filter((e) => {
      const file = vault.getAbstractFileByPath(e.path);
      return file !== null;
    });
    if (validEmbeddings.length !== embeddings.length) {
      await this.db.setItem("embeddings", validEmbeddings);
    }
  }
  async clearAllData() {
    if (!this.isInitialized)
      return;
    const keys = await this.db.keys();
    for (const key of keys) {
      await this.db.removeItem(key);
    }
  }
};

// src/services/PluginAPI.ts
var import_obsidian10 = require("obsidian");

// src/services/VoiceService.ts
var import_obsidian8 = require("obsidian");
var VoiceService = class {
  constructor(plugin) {
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
    this.recordingStartTime = 0;
    this.stream = null;
    this.plugin = plugin;
  }
  async startRecording() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(this.stream);
      this.audioChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.start();
      this.isRecording = true;
      this.recordingStartTime = Date.now();
      new import_obsidian8.Notice("\u{1F399}\uFE0F Recording started...");
      return true;
    } catch (error) {
      console.error("Failed to start recording:", error);
      new import_obsidian8.Notice("\u274C Failed to access microphone. Please check permissions.");
      return false;
    }
  }
  stopRecording() {
    return new Promise((resolve) => {
      if (!this.mediaRecorder || !this.isRecording) {
        resolve(null);
        return;
      }
      const duration = Date.now() - this.recordingStartTime;
      this.mediaRecorder.onstop = () => {
        var _a;
        const audioBlob = new Blob(this.audioChunks, { type: "audio/webm" });
        (_a = this.stream) == null ? void 0 : _a.getTracks().forEach((track) => track.stop());
        const recording = {
          id: crypto.randomUUID(),
          blob: audioBlob,
          duration,
          timestamp: Date.now()
        };
        this.isRecording = false;
        this.audioChunks = [];
        new import_obsidian8.Notice(`\u2705 Recording saved (${Math.round(duration / 1e3)}s)`);
        resolve(recording);
      };
      this.mediaRecorder.stop();
    });
  }
  cancelRecording() {
    var _a;
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      (_a = this.stream) == null ? void 0 : _a.getTracks().forEach((track) => track.stop());
      this.isRecording = false;
      this.audioChunks = [];
      new import_obsidian8.Notice("Recording cancelled");
    }
  }
  async transcribeRecording(recording) {
    try {
      const base64Audio = await this.blobToBase64(recording.blob);
      if (this.plugin.settings.openaiApiKey) {
        return await this.transcribeWithWhisper(base64Audio);
      }
      new import_obsidian8.Notice("\u26A0\uFE0F Using OpenAI for transcription. Add API key in settings.");
      return "[Audio message - transcription requires OpenAI API key]";
    } catch (error) {
      console.error("Transcription error:", error);
      return "[Transcription failed]";
    }
  }
  async transcribeWithWhisper(base64Audio) {
    const base64Data = base64Audio.split(",")[1] || base64Audio;
    const byteCharacters = atob(base64Data);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: "audio/webm" });
    const formData = new FormData();
    formData.append("file", blob, "recording.webm");
    formData.append("model", "whisper-1");
    const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`
      },
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Transcription failed: ${response.statusText}`);
    }
    const data = await response.json();
    return data.text;
  }
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  createAudioUrl(recording) {
    return URL.createObjectURL(recording.blob);
  }
  formatDuration(ms) {
    const seconds = Math.floor(ms / 1e3);
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  }
  downloadRecording(recording, filename) {
    const url = this.createAudioUrl(recording);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || `voice-message-${recording.id}.webm`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

// src/services/HandwritingService.ts
var import_obsidian9 = require("obsidian");
var HandwritingService = class {
  constructor(plugin) {
    this.currentCanvas = null;
    this.isDrawing = false;
    this.currentStroke = null;
    this.canvasElement = null;
    this.ctx = null;
    // Default settings
    this.strokeColor = "#1a1a1a";
    this.strokeWidth = 3;
    this.eraserMode = false;
    this.plugin = plugin;
  }
  initializeCanvas(canvas, width = 800, height = 600) {
    this.canvasElement = canvas;
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Could not get canvas context");
    }
    this.ctx = ctx;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, width, height);
    this.currentCanvas = {
      id: crypto.randomUUID(),
      strokes: [],
      width,
      height,
      backgroundColor: "#ffffff",
      timestamp: Date.now()
    };
    this.attachEventListeners(canvas);
    return this.currentCanvas;
  }
  attachEventListeners(canvas) {
    canvas.addEventListener("mousedown", this.handleStart.bind(this));
    canvas.addEventListener("mousemove", this.handleMove.bind(this));
    canvas.addEventListener("mouseup", this.handleEnd.bind(this));
    canvas.addEventListener("mouseout", this.handleEnd.bind(this));
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    });
    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent("mousemove", {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    });
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      const mouseEvent = new MouseEvent("mouseup", {});
      canvas.dispatchEvent(mouseEvent);
    });
  }
  handleStart(e) {
    var _a;
    if (!this.canvasElement || !this.ctx)
      return;
    this.isDrawing = true;
    const rect = this.canvasElement.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    this.currentStroke = {
      points: [{ x, y }],
      color: this.eraserMode ? ((_a = this.currentCanvas) == null ? void 0 : _a.backgroundColor) || "#ffffff" : this.strokeColor,
      width: this.eraserMode ? this.strokeWidth * 5 : this.strokeWidth
    };
    this.ctx.beginPath();
    this.ctx.moveTo(x, y);
    this.ctx.strokeStyle = this.currentStroke.color;
    this.ctx.lineWidth = this.currentStroke.width;
  }
  handleMove(e) {
    if (!this.isDrawing || !this.canvasElement || !this.ctx || !this.currentStroke)
      return;
    const rect = this.canvasElement.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    this.currentStroke.points.push({ x, y });
    this.ctx.lineTo(x, y);
    this.ctx.stroke();
  }
  handleEnd() {
    var _a;
    if (!this.isDrawing || !this.currentStroke)
      return;
    this.isDrawing = false;
    (_a = this.currentCanvas) == null ? void 0 : _a.strokes.push(this.currentStroke);
    this.currentStroke = null;
  }
  setStrokeColor(color) {
    this.strokeColor = color;
    this.eraserMode = false;
  }
  setStrokeWidth(width) {
    this.strokeWidth = width;
  }
  toggleEraser() {
    this.eraserMode = !this.eraserMode;
    return this.eraserMode;
  }
  undo() {
    if (!this.currentCanvas || this.currentCanvas.strokes.length === 0 || !this.ctx || !this.canvasElement) {
      new import_obsidian9.Notice("Nothing to undo");
      return;
    }
    this.currentCanvas.strokes.pop();
    this.redrawCanvas();
    new import_obsidian9.Notice("Undo successful");
  }
  clear() {
    if (!this.ctx || !this.canvasElement || !this.currentCanvas)
      return;
    this.ctx.fillStyle = this.currentCanvas.backgroundColor;
    this.ctx.fillRect(0, 0, this.canvasElement.width, this.canvasElement.height);
    this.currentCanvas.strokes = [];
    new import_obsidian9.Notice("Canvas cleared");
  }
  redrawCanvas() {
    if (!this.ctx || !this.canvasElement || !this.currentCanvas)
      return;
    this.ctx.fillStyle = this.currentCanvas.backgroundColor;
    this.ctx.fillRect(0, 0, this.canvasElement.width, this.canvasElement.height);
    this.currentCanvas.strokes.forEach((stroke) => {
      if (stroke.points.length < 2)
        return;
      this.ctx.beginPath();
      this.ctx.strokeStyle = stroke.color;
      this.ctx.lineWidth = stroke.width;
      this.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
      for (let i = 1; i < stroke.points.length; i++) {
        this.ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
      }
      this.ctx.stroke();
    });
  }
  async convertToImage() {
    if (!this.canvasElement) {
      throw new Error("Canvas not initialized");
    }
    return this.canvasElement.toDataURL("image/png");
  }
  async convertToNote(filename) {
    const imageData = await this.convertToImage();
    const timestamp = new Date().toISOString();
    const title = filename || `Handwriting-${Date.now()}`;
    let content = `# ${title}

`;
    content += `*Created: ${timestamp}*

`;
    content += `## Handwriting Canvas

`;
    content += `![Handwriting](${imageData})

`;
    content += `## Transcription

`;
    content += `*[OCR transcription would appear here - feature coming soon]*
`;
    return content;
  }
  downloadAsImage(filename) {
    if (!this.canvasElement)
      return;
    const link = document.createElement("a");
    link.download = filename || `handwriting-${Date.now()}.png`;
    link.href = this.canvasElement.toDataURL("image/png");
    link.click();
  }
  exportStrokes() {
    if (!this.currentCanvas)
      return "";
    return JSON.stringify(this.currentCanvas, null, 2);
  }
  importStrokes(json) {
    try {
      const canvas = JSON.parse(json);
      this.currentCanvas = canvas;
      this.redrawCanvas();
      new import_obsidian9.Notice("Handwriting imported successfully");
      return true;
    } catch (error) {
      new import_obsidian9.Notice("Failed to import handwriting");
      return false;
    }
  }
  getPresetColors() {
    return [
      "#1a1a1a",
      // Black
      "#dc2626",
      // Red
      "#16a34a",
      // Green
      "#2563eb",
      // Blue
      "#9333ea",
      // Purple
      "#ea580c",
      // Orange
      "#0891b2",
      // Cyan
      "#db2777"
      // Pink
    ];
  }
};

// src/services/KnowledgeGraphService.ts
var KnowledgeGraphService = class {
  constructor(plugin) {
    this.graph = { nodes: [], edges: [] };
    this.clusters = [];
    // Color palette for different node types
    this.colors = {
      note: "#667eea",
      tag: "#10b981",
      link: "#f59e0b",
      concept: "#ec4899"
    };
    this.plugin = plugin;
  }
  async buildGraph() {
    var _a, _b;
    const nodes = [];
    const edges = [];
    const nodeMap = /* @__PURE__ */ new Map();
    const files = this.plugin.app.vault.getMarkdownFiles();
    for (const file of files) {
      const node = {
        id: file.path,
        label: file.basename,
        type: "note",
        size: 10,
        color: this.colors.note,
        metadata: {
          path: file.path,
          created: file.stat.ctime,
          modified: file.stat.mtime,
          tags: []
        }
      };
      nodes.push(node);
      nodeMap.set(file.path, node);
    }
    for (const file of files) {
      const content = await this.plugin.app.vault.read(file);
      const sourceNode = nodeMap.get(file.path);
      if (!sourceNode)
        continue;
      const linkMatches = content.matchAll(/\[\[([^\]]+)\]\]/g);
      for (const match of linkMatches) {
        const linkText = match[1];
        const targetPath = this.resolveLink(linkText, file);
        if (targetPath && nodeMap.has(targetPath)) {
          edges.push({
            source: file.path,
            target: targetPath,
            type: "link",
            weight: 1
          });
          sourceNode.size += 2;
          const targetNode = nodeMap.get(targetPath);
          if (targetNode)
            targetNode.size += 2;
        }
      }
      const tagMatches = content.matchAll(/#(\w+)/g);
      const tags = /* @__PURE__ */ new Set();
      for (const match of tagMatches) {
        tags.add(match[1]);
      }
      for (const tag of tags) {
        const tagId = `tag:${tag}`;
        if (!nodeMap.has(tagId)) {
          const tagNode = {
            id: tagId,
            label: `#${tag}`,
            type: "tag",
            size: 8,
            color: this.colors.tag
          };
          nodes.push(tagNode);
          nodeMap.set(tagId, tagNode);
        }
        edges.push({
          source: file.path,
          target: tagId,
          type: "tag",
          weight: 0.5
        });
        (_b = (_a = sourceNode.metadata) == null ? void 0 : _a.tags) == null ? void 0 : _b.push(tag);
      }
      const conceptMatches = content.matchAll(/\b(AI|machine learning|deep learning|neural network|data|algorithm|model|training)\b/gi);
      const concepts = /* @__PURE__ */ new Set();
      for (const match of conceptMatches) {
        concepts.add(match[0].toLowerCase());
      }
      for (const concept of concepts) {
        const conceptId = `concept:${concept}`;
        if (!nodeMap.has(conceptId)) {
          const conceptNode = {
            id: conceptId,
            label: concept,
            type: "concept",
            size: 6,
            color: this.colors.concept
          };
          nodes.push(conceptNode);
          nodeMap.set(conceptId, conceptNode);
        }
        edges.push({
          source: file.path,
          target: conceptId,
          type: "reference",
          weight: 0.3
        });
      }
    }
    this.graph = { nodes, edges };
    return this.graph;
  }
  resolveLink(linkText, sourceFile) {
    const files = this.plugin.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.basename === linkText || file.path === linkText) {
        return file.path;
      }
    }
    for (const file of files) {
      if (file.basename.toLowerCase().includes(linkText.toLowerCase())) {
        return file.path;
      }
    }
    return null;
  }
  async findSimilarNotes(file, limit = 5) {
    const content = await this.plugin.app.vault.read(file);
    const similar = await this.plugin.searchService.semanticSearch(content.substring(0, 500));
    return similar.filter((f) => f.path !== file.path).slice(0, limit);
  }
  calculateGraphStats() {
    const { nodes, edges } = this.graph;
    const connectivity = /* @__PURE__ */ new Map();
    nodes.forEach((n) => connectivity.set(n.id, 0));
    edges.forEach((e) => {
      connectivity.set(e.source, (connectivity.get(e.source) || 0) + 1);
      connectivity.set(e.target, (connectivity.get(e.target) || 0) + 1);
    });
    const isolatedNodes = nodes.filter((n) => (connectivity.get(n.id) || 0) === 0).length;
    const avgConnectivity = nodes.length > 0 ? Array.from(connectivity.values()).reduce((a, b) => a + b, 0) / nodes.length : 0;
    return {
      totalNodes: nodes.length,
      totalEdges: edges.length,
      avgConnectivity: Math.round(avgConnectivity * 100) / 100,
      isolatedNodes,
      clusters: this.clusters.length
    };
  }
  findPath(startId, endId) {
    const queue = [startId];
    const visited = /* @__PURE__ */ new Set([startId]);
    const parent = /* @__PURE__ */ new Map();
    while (queue.length > 0) {
      const current = queue.shift();
      if (current === endId) {
        const path = [];
        let nodeId = endId;
        while (nodeId) {
          const node = this.graph.nodes.find((n) => n.id === nodeId);
          if (node)
            path.unshift(node);
          nodeId = parent.get(nodeId);
        }
        return path;
      }
      const neighbors = this.graph.edges.filter((e) => e.source === current || e.target === current).map((e) => e.source === current ? e.target : e.source);
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          parent.set(neighbor, current);
          queue.push(neighbor);
        }
      }
    }
    return null;
  }
  getConnectedNodes(nodeId) {
    const connectedIds = /* @__PURE__ */ new Set();
    this.graph.edges.forEach((edge) => {
      if (edge.source === nodeId)
        connectedIds.add(edge.target);
      if (edge.target === nodeId)
        connectedIds.add(edge.source);
    });
    return this.graph.nodes.filter((n) => connectedIds.has(n.id));
  }
  exportGraph() {
    return JSON.stringify(this.graph, null, 2);
  }
  importGraph(json) {
    try {
      this.graph = JSON.parse(json);
      return true;
    } catch (error) {
      return false;
    }
  }
  // Force-directed layout calculation
  calculateLayout(iterations = 100) {
    const { nodes, edges } = this.graph;
    const width = 1e3;
    const height = 800;
    const k = Math.sqrt(width * height / nodes.length) * 0.5;
    nodes.forEach((node) => {
      if (node.x === void 0)
        node.x = Math.random() * width;
      if (node.y === void 0)
        node.y = Math.random() * height;
    });
    for (let i = 0; i < iterations; i++) {
      for (let a = 0; a < nodes.length; a++) {
        for (let b = a + 1; b < nodes.length; b++) {
          const nodeA = nodes[a];
          const nodeB = nodes[b];
          const dx = nodeA.x - nodeB.x;
          const dy = nodeA.y - nodeB.y;
          const distance = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = k * k / distance;
          const fx = dx / distance * force;
          const fy = dy / distance * force;
          nodeA.x += fx * 0.1;
          nodeA.y += fy * 0.1;
          nodeB.x -= fx * 0.1;
          nodeB.y -= fy * 0.1;
        }
      }
      edges.forEach((edge) => {
        const source = nodes.find((n) => n.id === edge.source);
        const target = nodes.find((n) => n.id === edge.target);
        if (source && target) {
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          const distance = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = distance * distance / k;
          const fx = dx / distance * force * 0.1 * edge.weight;
          const fy = dy / distance * force * 0.1 * edge.weight;
          source.x += fx;
          source.y += fy;
          target.x -= fx;
          target.y -= fy;
        }
      });
      nodes.forEach((node) => {
        const dx = node.x - width / 2;
        const dy = node.y - height / 2;
        node.x -= dx * 0.01;
        node.y -= dy * 0.01;
      });
    }
    nodes.forEach((node) => {
      node.x = Math.max(50, Math.min(width - 50, node.x));
      node.y = Math.max(50, Math.min(height - 50, node.y));
    });
  }
  filterGraph(options) {
    let filteredNodes = [...this.graph.nodes];
    if (options.nodeTypes) {
      filteredNodes = filteredNodes.filter((n) => options.nodeTypes.includes(n.type));
    }
    if (options.minConnections !== void 0) {
      const connectivity = /* @__PURE__ */ new Map();
      this.graph.edges.forEach((e) => {
        connectivity.set(e.source, (connectivity.get(e.source) || 0) + 1);
        connectivity.set(e.target, (connectivity.get(e.target) || 0) + 1);
      });
      filteredNodes = filteredNodes.filter((n) => (connectivity.get(n.id) || 0) >= options.minConnections);
    }
    if (options.searchQuery) {
      const query = options.searchQuery.toLowerCase();
      filteredNodes = filteredNodes.filter(
        (n) => n.label.toLowerCase().includes(query) || n.id.toLowerCase().includes(query)
      );
    }
    const nodeIds = new Set(filteredNodes.map((n) => n.id));
    const filteredEdges = this.graph.edges.filter(
      (e) => nodeIds.has(e.source) && nodeIds.has(e.target)
    );
    return { nodes: filteredNodes, edges: filteredEdges };
  }
};

// src/services/PluginAPI.ts
var PluginAPI = class {
  constructor(plugin) {
    // Registered extensions
    this.extensions = /* @__PURE__ */ new Map();
    // Registered commands
    this.commands = /* @__PURE__ */ new Map();
    // Event listeners
    this.eventListeners = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.ai = plugin.aiService;
    this.search = plugin.searchService;
    this.chat = plugin.chatService;
    this.voice = new VoiceService(plugin);
    this.handwriting = new HandwritingService(plugin);
    this.graph = new KnowledgeGraphService(plugin);
  }
  // ==================== Extension Management ====================
  registerExtension(extension) {
    if (this.extensions.has(extension.id)) {
      console.warn(`Extension ${extension.id} is already registered`);
      return false;
    }
    try {
      extension.onLoad(this);
      this.extensions.set(extension.id, extension);
      new import_obsidian10.Notice(`Extension "${extension.name}" loaded`);
      return true;
    } catch (error) {
      console.error(`Failed to load extension ${extension.id}:`, error);
      return false;
    }
  }
  unregisterExtension(extensionId) {
    const extension = this.extensions.get(extensionId);
    if (!extension)
      return false;
    try {
      extension.onUnload();
      this.extensions.delete(extensionId);
      new import_obsidian10.Notice(`Extension "${extension.name}" unloaded`);
      return true;
    } catch (error) {
      console.error(`Failed to unload extension ${extensionId}:`, error);
      return false;
    }
  }
  getExtension(extensionId) {
    return this.extensions.get(extensionId);
  }
  getAllExtensions() {
    return Array.from(this.extensions.values());
  }
  // ==================== Command Registration ====================
  registerCommand(command) {
    if (this.commands.has(command.id)) {
      console.warn(`Command ${command.id} is already registered`);
      return;
    }
    this.commands.set(command.id, command);
    this.plugin.addCommand({
      id: `api-${command.id}`,
      name: command.name,
      callback: command.callback
    });
  }
  unregisterCommand(commandId) {
    this.commands.delete(commandId);
  }
  executeCommand(commandId) {
    const command = this.commands.get(commandId);
    if (command) {
      command.callback();
    } else {
      console.warn(`Command ${commandId} not found`);
    }
  }
  // ==================== Event System ====================
  on(event, callback) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(event).add(callback);
    return () => {
      var _a;
      (_a = this.eventListeners.get(event)) == null ? void 0 : _a.delete(callback);
    };
  }
  off(event, callback) {
    var _a;
    (_a = this.eventListeners.get(event)) == null ? void 0 : _a.delete(callback);
  }
  emit(event, data) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach((callback) => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event listener for ${event}:`, error);
        }
      });
    }
    this.extensions.forEach((ext) => {
      if (event === "message:received" && ext.onMessage) {
        ext.onMessage(data == null ? void 0 : data.message, data == null ? void 0 : data.context);
      }
      if (event === "note:opened" && ext.onNoteOpen) {
        ext.onNoteOpen(data);
      }
      if (event === "settings:changed" && ext.onSettingsChange) {
        ext.onSettingsChange(data);
      }
    });
  }
  // ==================== Utility Methods ====================
  async createNote(title, content, folder) {
    const folderPath = folder || "";
    const fileName = `${folderPath}${title}.md`;
    try {
      if (folder) {
        const existingFolder = this.plugin.app.vault.getAbstractFileByPath(folder);
        if (!existingFolder) {
          await this.plugin.app.vault.createFolder(folder);
        }
      }
      return await this.plugin.app.vault.create(fileName, content);
    } catch (error) {
      console.error("Failed to create note:", error);
      return null;
    }
  }
  async readNote(file) {
    const targetFile = typeof file === "string" ? this.plugin.app.vault.getAbstractFileByPath(file) : file;
    if (targetFile instanceof import_obsidian10.TFile) {
      return await this.plugin.app.vault.read(targetFile);
    }
    throw new Error("File not found");
  }
  async updateNote(file, content) {
    const targetFile = typeof file === "string" ? this.plugin.app.vault.getAbstractFileByPath(file) : file;
    if (targetFile instanceof import_obsidian10.TFile) {
      await this.plugin.app.vault.modify(targetFile, content);
    } else {
      throw new Error("File not found");
    }
  }
  getAllNotes() {
    return this.plugin.app.vault.getMarkdownFiles();
  }
  async searchNotes(query) {
    return await this.search.semanticSearch(query);
  }
  showNotice(message, duration) {
    new import_obsidian10.Notice(message, duration);
  }
  // ==================== AI Enhancement Methods ====================
  async enhanceWithAI(text, enhancement) {
    const prompts = {
      summarize: `Summarize the following text concisely:

${text}`,
      expand: `Expand on the following text with more detail:

${text}`,
      rewrite: `Rewrite the following text to improve clarity and flow:

${text}`,
      translate: `Translate the following text to English (if not already) or maintain the current language:

${text}`
    };
    return this.ai.generateResponse(prompts[enhancement]);
  }
  async suggestConnections(file) {
    const content = await this.readNote(file);
    return await this.search.semanticSearch(content.substring(0, 1e3));
  }
  async generateTags(content) {
    const prompt = `Generate 3-5 relevant tags for the following content. Return only the tags separated by commas, without the # symbol:

${content.substring(0, 500)}`;
    const response = await this.ai.generateResponse(prompt);
    return response.split(",").map((t) => t.trim()).filter((t) => t);
  }
  // ==================== Settings Access ====================
  getSettings() {
    return { ...this.plugin.settings };
  }
  async updateSettings(partialSettings) {
    Object.assign(this.plugin.settings, partialSettings);
    await this.plugin.saveSettings();
    this.emit("settings:changed", this.plugin.settings);
  }
  // ==================== UI Methods ====================
  openChatView() {
    this.plugin.activateChatView();
  }
  openNoteBrowserView() {
    this.plugin.activateNoteBrowserView();
  }
  openSemanticSearch() {
    this.plugin.openSemanticSearch();
  }
  // ==================== Extension Helper Methods ====================
  /**
   * Helper to create a simple extension
   */
  createExtension(config) {
    return {
      id: config.id,
      name: config.name,
      version: config.version,
      onLoad: config.onLoad || (() => {
      }),
      onUnload: config.onUnload || (() => {
      }),
      onMessage: config.onMessage
    };
  }
  /**
   * Example extension for documentation
   */
  getExampleExtension() {
    return `
// Example Extension
const myExtension = {
	id: 'my-custom-extension',
	name: 'My Custom Extension',
	version: '1.0.0',
	author: 'Your Name',
	
	onLoad(api) {
		// Register a command
		api.registerCommand({
			id: 'say-hello',
			name: 'Say Hello',
			callback: () => {
				api.showNotice('Hello from my extension!');
			}
		});
		
		// Listen for events
		api.on('message:received', (data) => {
			console.log('New message:', data.message);
		});
	},
	
	onUnload() {
		console.log('Extension unloaded');
	},
	
	async onMessage(message, context) {
		// Process messages
		if (message.includes('hello')) {
			return 'Hello there!';
		}
		return null;
	}
};

// Register the extension
app.plugins.plugins['ai-chat-notes'].api.registerExtension(myExtension);
		`.trim();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  aiProvider: "ollama",
  openaiApiKey: "",
  anthropicApiKey: "",
  ollamaUrl: "http://localhost:11434",
  localModelPath: "",
  defaultModel: "llama3.2",
  enableLiquidGlass: true,
  messageBubbleStyle: "modern",
  chatFontSize: 16,
  enableTypingIndicators: true,
  enableReadReceipts: true,
  enableSemanticSearch: true,
  embeddingModel: "nomic-embed-text",
  autoSyncInterval: 3e5,
  // 5 minutes
  maxContextNotes: 5,
  enableLocalMode: true,
  storeChatHistory: true,
  encryptData: false,
  theme: "system",
  accentColor: "#667eea",
  borderRadius: 16,
  debugMode: false,
  maxTokens: 2048,
  temperature: 0.7
};
var AIChatNotesPlugin = class extends import_obsidian11.Plugin {
  async onload() {
    await this.loadSettings();
    this.dbManager = new DatabaseManager(this);
    await this.dbManager.initialize();
    this.aiService = new AIService(this.settings);
    this.searchService = new SearchService(this);
    this.chatService = new ChatService(this);
    this.api = new PluginAPI(this);
    this.voiceService = new VoiceService(this);
    this.registerIcons();
    this.registerView(
      VIEW_TYPE_AI_CHAT,
      (leaf) => new AIChatView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_NOTE_BROWSER,
      (leaf) => new NoteBrowserView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_HANDWRITING,
      (leaf) => new HandwritingView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_KNOWLEDGE_GRAPH,
      (leaf) => new KnowledgeGraphView(leaf, this)
    );
    this.addRibbonIcon("message-circle", "Open AI Chat", () => {
      this.activateChatView();
    });
    this.addRibbonIcon("book-open", "Note Browser", () => {
      this.activateNoteBrowserView();
    });
    this.addRibbonIcon("pen-tool", "Handwriting Canvas", () => {
      this.activateHandwritingView();
    });
    this.addRibbonIcon("git-branch", "Knowledge Graph", () => {
      this.activateKnowledgeGraphView();
    });
    this.addCommand({
      id: "open-ai-chat",
      name: "Open AI Chat",
      callback: () => this.activateChatView()
    });
    this.addCommand({
      id: "open-note-browser",
      name: "Open Note Browser",
      callback: () => this.activateNoteBrowserView()
    });
    this.addCommand({
      id: "ask-ai-about-note",
      name: "Ask AI about current note",
      editorCallback: (editor, view) => {
        this.askAIAboutNote(view.file);
      }
    });
    this.addCommand({
      id: "semantic-search",
      name: "Semantic Search",
      callback: () => this.openSemanticSearch()
    });
    this.addCommand({
      id: "convert-chat-to-note",
      name: "Convert chat to note",
      callback: () => this.convertChatToNote()
    });
    this.addCommand({
      id: "open-handwriting-canvas",
      name: "Open Handwriting Canvas",
      callback: () => this.activateHandwritingView()
    });
    this.addCommand({
      id: "open-knowledge-graph",
      name: "Open Knowledge Graph",
      callback: () => this.activateKnowledgeGraphView()
    });
    this.addCommand({
      id: "start-voice-recording",
      name: "Start Voice Recording",
      callback: () => this.startVoiceRecording()
    });
    this.addSettingTab(new AIChatNotesSettingTab(this.app, this));
    this.injectStyles();
    this.initializeAutoSync();
    console.log("AI Chat & Notes plugin loaded");
  }
  onunload() {
    var _a;
    (_a = this.dbManager) == null ? void 0 : _a.close();
    console.log("AI Chat & Notes plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.aiService.updateSettings(this.settings);
  }
  registerIcons() {
    (0, import_obsidian11.addIcon)("message-circle", `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/></svg>`);
    (0, import_obsidian11.addIcon)("brain", `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z"/><path d="M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z"/><path d="M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4"/><path d="M17.599 6.5a3 3 0 0 0 .399-1.375"/><path d="M6.003 5.125A3 3 0 0 0 6.401 6.5"/><path d="M3.477 10.896a4 4 0 0 1 .585-.396"/><path d="M19.938 10.5a4 4 0 0 1 .585.396"/><path d="M6 18a4 4 0 0 1-1.967-.516"/><path d="M19.967 17.484A4 4 0 0 1 18 18"/></svg>`);
  }
  injectStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "ai-chat-notes-styles";
    styleEl.textContent = LIQUID_GLASS_STYLES;
    document.head.appendChild(styleEl);
  }
  initializeAutoSync() {
    if (this.settings.autoSyncInterval > 0) {
      this.registerInterval(
        window.setInterval(() => {
          this.searchService.syncEmbeddings();
        }, this.settings.autoSyncInterval)
      );
    }
  }
  async activateChatView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_AI_CHAT)[0];
    if (!leaf) {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        new import_obsidian11.Notice("Failed to create AI Chat view");
        return;
      }
      await leaf.setViewState({ type: VIEW_TYPE_AI_CHAT, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async activateNoteBrowserView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_NOTE_BROWSER)[0];
    if (!leaf) {
      leaf = workspace.getLeftLeaf(false);
      if (!leaf) {
        new import_obsidian11.Notice("Failed to create Note Browser view");
        return;
      }
      await leaf.setViewState({ type: VIEW_TYPE_NOTE_BROWSER, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async askAIAboutNote(file) {
    if (!file) {
      new import_obsidian11.Notice("No note is currently open");
      return;
    }
    const content = await this.app.vault.read(file);
    await this.activateChatView();
    const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_AI_CHAT)[0];
    if (leaf && leaf.view instanceof AIChatView) {
      leaf.view.setContextNote(file.name, content);
    }
  }
  async openSemanticSearch() {
    new SemanticSearchModal(this.app, this).open();
  }
  async convertChatToNote() {
    new ChatToNoteModal(this.app, this).open();
  }
  // Phase 3 methods
  async activateHandwritingView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_HANDWRITING)[0];
    if (!leaf) {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        new import_obsidian11.Notice("Failed to create Handwriting view");
        return;
      }
      await leaf.setViewState({ type: VIEW_TYPE_HANDWRITING, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async activateKnowledgeGraphView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_KNOWLEDGE_GRAPH)[0];
    if (!leaf) {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        new import_obsidian11.Notice("Failed to create Knowledge Graph view");
        return;
      }
      await leaf.setViewState({ type: VIEW_TYPE_KNOWLEDGE_GRAPH, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async startVoiceRecording() {
    if (this.voiceService.isRecording) {
      const recording = await this.voiceService.stopRecording();
      if (recording) {
        const transcription = await this.voiceService.transcribeRecording(recording);
        await this.activateChatView();
        const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_AI_CHAT)[0];
        if (leaf && leaf.view instanceof AIChatView) {
          const textArea = leaf.view.containerEl.querySelector(".ai-chat-input");
          if (textArea) {
            textArea.value = transcription;
          }
        }
      }
    } else {
      await this.voiceService.startRecording();
    }
  }
};
var AIChatNotesSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Chat & Notes Settings" });
    containerEl.createEl("h3", { text: "AI Provider" });
    new import_obsidian11.Setting(containerEl).setName("AI Provider").setDesc("Select your preferred AI provider").addDropdown((dropdown) => dropdown.addOption("ollama", "Ollama (Local)").addOption("openai", "OpenAI").addOption("anthropic", "Anthropic (Claude)").addOption("local", "Local Model").setValue(this.plugin.settings.aiProvider).onChange(async (value) => {
      this.plugin.settings.aiProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.aiProvider === "openai") {
      new import_obsidian11.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.aiProvider === "anthropic") {
      new import_obsidian11.Setting(containerEl).setName("Anthropic API Key").setDesc("Your Anthropic API key").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.aiProvider === "ollama") {
      new import_obsidian11.Setting(containerEl).setName("Ollama URL").setDesc("URL of your Ollama instance").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaUrl).onChange(async (value) => {
        this.plugin.settings.ollamaUrl = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian11.Setting(containerEl).setName("Default Model").setDesc("Model to use for AI responses").addText((text) => text.setPlaceholder("llama3.2").setValue(this.plugin.settings.defaultModel).onChange(async (value) => {
      this.plugin.settings.defaultModel = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "UI Settings" });
    new import_obsidian11.Setting(containerEl).setName("Enable Liquid Glass Design").setDesc("Use modern glass-morphism design effects").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableLiquidGlass).onChange(async (value) => {
      this.plugin.settings.enableLiquidGlass = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Message Bubble Style").setDesc("Style of chat message bubbles").addDropdown((dropdown) => dropdown.addOption("modern", "Modern (Liquid Glass)").addOption("classic", "Classic").addOption("minimal", "Minimal").setValue(this.plugin.settings.messageBubbleStyle).onChange(async (value) => {
      this.plugin.settings.messageBubbleStyle = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Chat Font Size").setDesc("Font size for chat messages (px)").addSlider((slider) => slider.setLimits(12, 24, 1).setValue(this.plugin.settings.chatFontSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chatFontSize = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Features" });
    new import_obsidian11.Setting(containerEl).setName("Enable Semantic Search").setDesc("Use AI embeddings for note search").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSemanticSearch).onChange(async (value) => {
      this.plugin.settings.enableSemanticSearch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Max Context Notes").setDesc("Maximum number of notes to include as context").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.maxContextNotes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxContextNotes = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Privacy" });
    new import_obsidian11.Setting(containerEl).setName("Enable Local Mode").setDesc("Process everything locally without cloud services").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableLocalMode).onChange(async (value) => {
      this.plugin.settings.enableLocalMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Store Chat History").setDesc("Save chat conversations to local database").addToggle((toggle) => toggle.setValue(this.plugin.settings.storeChatHistory).onChange(async (value) => {
      this.plugin.settings.storeChatHistory = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Advanced" });
    new import_obsidian11.Setting(containerEl).setName("Temperature").setDesc("AI creativity level (0.0 - 1.0)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens per AI response").addText((text) => text.setPlaceholder("2048").setValue(String(this.plugin.settings.maxTokens)).onChange(async (value) => {
      this.plugin.settings.maxTokens = parseInt(value) || 2048;
      await this.plugin.saveSettings();
    }));
  }
};
var SemanticSearchModal = class extends import_obsidian11.Modal {
  constructor(app, plugin) {
    super(app);
    this.results = [];
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("semantic-search-modal");
    contentEl.createEl("h2", { text: "Semantic Search" });
    const inputContainer = contentEl.createDiv({ cls: "search-input-container" });
    const input = inputContainer.createEl("input", {
      type: "text",
      placeholder: "Search your notes with natural language...",
      cls: "semantic-search-input"
    });
    const resultsContainer = contentEl.createDiv({ cls: "search-results" });
    input.addEventListener("input", async (e) => {
      const query = e.target.value;
      if (query.length > 2) {
        this.results = await this.plugin.searchService.semanticSearch(query);
        this.renderResults(resultsContainer);
      }
    });
    input.focus();
  }
  renderResults(container) {
    container.empty();
    if (this.results.length === 0) {
      container.createEl("p", { text: "No results found", cls: "no-results" });
      return;
    }
    this.results.forEach((file) => {
      const resultItem = container.createDiv({ cls: "search-result-item" });
      resultItem.createEl("span", { text: file.basename, cls: "result-title" });
      resultItem.createEl("span", { text: file.path, cls: "result-path" });
      resultItem.addEventListener("click", () => {
        this.app.workspace.openLinkText(file.path, "", true);
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ChatToNoteModal = class extends import_obsidian11.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Convert Chat to Note" });
    contentEl.createEl("p", { text: "Select a chat conversation to convert to a note:" });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LIQUID_GLASS_STYLES = `
/* Phase 3 - Handwriting Canvas Styles */
.handwriting-view {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.handwriting-header {
  padding: 16px;
  border-bottom: 1px solid var(--ai-glass-border);
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
}

.handwriting-header h3 {
  margin: 0;
  font-size: 18px;
}

.handwriting-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid var(--ai-glass-border);
  align-items: center;
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: 8px;
}

.toolbar-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
}

.color-btn {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 2px solid transparent;
  cursor: pointer;
  transition: transform 0.2s, border-color 0.2s;
}

.color-btn:hover {
  transform: scale(1.1);
}

.color-btn.active {
  border-color: var(--text-normal);
  box-shadow: 0 0 0 2px var(--background-primary);
}

.brush-size-slider {
  width: 100px;
}

.tool-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid var(--ai-glass-border);
  background: var(--ai-glass-bg);
  cursor: pointer;
  font-size: 13px;
  transition: all 0.2s;
}

.tool-btn:hover {
  background: var(--ai-primary);
  color: white;
}

.tool-btn.active {
  background: var(--ai-primary);
  color: white;
}

.tool-btn.danger:hover {
  background: #dc2626;
}

.canvas-container {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f5f5f5;
  padding: 20px;
  overflow: auto;
}

.theme-dark .canvas-container {
  background: #1a1a1a;
}

.handwriting-canvas {
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  cursor: crosshair;
  touch-action: none;
}

.handwriting-footer {
  display: flex;
  gap: 12px;
  padding: 16px;
  border-top: 1px solid var(--ai-glass-border);
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
}

.action-btn {
  padding: 10px 20px;
  border-radius: 8px;
  border: 1px solid var(--ai-glass-border);
  background: var(--ai-glass-bg);
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
}

.action-btn:hover {
  background: var(--ai-primary);
  color: white;
}

.action-btn.primary {
  background: var(--ai-primary-gradient);
  color: white;
  border: none;
}

/* Phase 3 - Knowledge Graph Styles */
.knowledge-graph-view {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.graph-header {
  padding: 16px;
  border-bottom: 1px solid var(--ai-glass-border);
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
}

.graph-header h3 {
  margin: 0;
  font-size: 18px;
}

.graph-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid var(--ai-glass-border);
  align-items: center;
}

.graph-btn {
  padding: 8px 16px;
  border-radius: 8px;
  border: 1px solid var(--ai-glass-border);
  background: var(--ai-glass-bg);
  cursor: pointer;
  font-size: 13px;
  transition: all 0.2s;
}

.graph-btn:hover {
  background: var(--ai-primary);
  color: white;
}

.graph-btn.primary {
  background: var(--ai-primary-gradient);
  color: white;
  border: none;
}

.filter-container {
  display: flex;
  gap: 16px;
  margin-left: auto;
}

.toggle-wrapper {
  display: flex;
  align-items: center;
  gap: 6px;
}

.toggle-label {
  font-size: 12px;
  color: var(--text-muted);
}

.toggle-checkbox {
  cursor: pointer;
}

.graph-stats {
  display: flex;
  gap: 16px;
  padding: 8px 16px;
  background: var(--background-secondary);
  font-size: 12px;
  color: var(--text-muted);
}

.graph-stats span {
  display: flex;
  align-items: center;
  gap: 4px;
}

.graph-canvas-container {
  flex: 1;
  position: relative;
  overflow: hidden;
  background: var(--background-primary);
}

.graph-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  cursor: grab;
}

.graph-canvas:active {
  cursor: grabbing;
}

/* Voice Recording Indicator */
.voice-recording-indicator {
  position: fixed;
  bottom: 80px;
  right: 20px;
  background: #dc2626;
  color: white;
  padding: 12px 20px;
  border-radius: 50px;
  display: flex;
  align-items: center;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(220, 38, 38, 0.4);
  animation: pulse 1.5s ease-in-out infinite;
  z-index: 1000;
}

.voice-recording-indicator::before {
  content: '\u{1F399}\uFE0F';
  font-size: 18px;
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
}

/* AI Chat & Notes - Liquid Glass Design System */

/* CSS Variables */
.ai-chat-notes-root {
  --ai-primary: #667eea;
  --ai-primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --ai-glass-bg: rgba(255, 255, 255, 0.7);
  --ai-glass-border: rgba(255, 255, 255, 0.3);
  --ai-glass-blur: blur(20px) saturate(180%);
  --ai-shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
  --ai-shadow-md: 0 8px 32px rgba(0, 0, 0, 0.1);
  --ai-shadow-lg: 0 12px 24px rgba(0, 0, 0, 0.15);
  --ai-border-radius: 16px;
  --ai-transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
  
  /* Message bubble colors */
  --ai-message-sent: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --ai-message-received: #f7fafc;
  --ai-message-text-sent: #ffffff;
  --ai-message-text-received: #1a1a1a;
}

.theme-dark .ai-chat-notes-root {
  --ai-glass-bg: rgba(30, 30, 30, 0.8);
  --ai-glass-border: rgba(255, 255, 255, 0.1);
  --ai-message-received: #2d2d2d;
  --ai-message-text-received: #e0e0e0;
}

/* Common Glass Effect */
.ai-glass {
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
  -webkit-backdrop-filter: var(--ai-glass-blur);
  border: 1px solid var(--ai-glass-border);
  border-radius: var(--ai-border-radius);
}

/* Message Bubbles */
.ai-message-bubble {
  max-width: 80%;
  padding: 12px 16px;
  border-radius: var(--ai-border-radius);
  box-shadow: var(--ai-shadow-sm);
  transition: var(--ai-transition);
  animation: messageAppear 0.3s ease-out;
  word-wrap: break-word;
}

@keyframes messageAppear {
  from {
    opacity: 0;
    transform: translateY(10px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.ai-message-bubble:hover {
  box-shadow: var(--ai-shadow-md);
  transform: scale(1.02);
}

.ai-message-bubble.sent {
  background: var(--ai-message-sent);
  color: var(--ai-message-text-sent);
  margin-left: auto;
  border-bottom-right-radius: 4px;
}

.ai-message-bubble.received {
  background: var(--ai-message-received);
  color: var(--ai-message-text-received);
  border-bottom-left-radius: 4px;
}

.ai-message-bubble.ai {
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
  border: 1px solid rgba(102, 126, 234, 0.3);
  color: var(--ai-message-text-received);
}

/* Chat Input Area */
.ai-chat-input-container {
  position: sticky;
  bottom: 0;
  padding: 16px;
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
  -webkit-backdrop-filter: var(--ai-glass-blur);
  border-top: 1px solid var(--ai-glass-border);
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.ai-chat-input {
  flex: 1;
  min-height: 44px;
  max-height: 200px;
  padding: 12px 16px;
  border: 1px solid var(--ai-glass-border);
  border-radius: calc(var(--ai-border-radius) / 2);
  background: rgba(255, 255, 255, 0.5);
  resize: none;
  outline: none;
  font-size: 16px;
  transition: var(--ai-transition);
}

.ai-chat-input:focus {
  border-color: var(--ai-primary);
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
}

.ai-send-button {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: var(--ai-primary-gradient);
  color: white;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--ai-transition);
  box-shadow: var(--ai-shadow-sm);
}

.ai-send-button:hover {
  transform: scale(1.1);
  box-shadow: var(--ai-shadow-md);
}

/* Typing Indicator */
.ai-typing-indicator {
  display: flex;
  gap: 4px;
  padding: 16px;
  align-items: center;
}

.ai-typing-indicator span {
  width: 8px;
  height: 8px;
  background: var(--ai-primary);
  border-radius: 50%;
  animation: typingBounce 1.4s ease-in-out infinite both;
}

.ai-typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
.ai-typing-indicator span:nth-child(2) { animation-delay: -0.16s; }

@keyframes typingBounce {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1); }
}

/* Semantic Search Modal */
.semantic-search-modal {
  min-width: 600px;
}

.semantic-search-input {
  width: 100%;
  padding: 16px 20px;
  font-size: 18px;
  border: 2px solid var(--ai-glass-border);
  border-radius: var(--ai-border-radius);
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
  outline: none;
  transition: var(--ai-transition);
}

.semantic-search-input:focus {
  border-color: var(--ai-primary);
  box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15);
}

.search-results {
  margin-top: 20px;
  max-height: 400px;
  overflow-y: auto;
}

.search-result-item {
  padding: 16px;
  border-radius: 12px;
  cursor: pointer;
  transition: var(--ai-transition);
  border: 1px solid transparent;
}

.search-result-item:hover {
  background: rgba(102, 126, 234, 0.05);
  border-color: rgba(102, 126, 234, 0.2);
}

.result-title {
  display: block;
  font-weight: 600;
  color: var(--ai-primary);
}

.result-path {
  display: block;
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 4px;
}

/* Note Browser */
.note-browser-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.note-browser-header {
  padding: 16px;
  border-bottom: 1px solid var(--ai-glass-border);
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
}

.note-browser-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.note-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  transition: var(--ai-transition);
  gap: 8px;
}

.note-item:hover {
  background: rgba(102, 126, 234, 0.1);
}

.note-item.active {
  background: var(--ai-primary-gradient);
  color: white;
}

/* AI Suggestions Panel */
.ai-suggestions-panel {
  position: absolute;
  bottom: 80px;
  left: 16px;
  right: 16px;
  background: var(--ai-glass-bg);
  backdrop-filter: var(--ai-glass-blur);
  border: 1px solid var(--ai-glass-border);
  border-radius: var(--ai-border-radius);
  padding: 12px;
  box-shadow: var(--ai-shadow-lg);
  z-index: 100;
}

.ai-suggestion-item {
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  transition: var(--ai-transition);
  display: flex;
  align-items: center;
  gap: 8px;
}

.ai-suggestion-item:hover {
  background: rgba(102, 126, 234, 0.1);
}

/* Context Panel */
.ai-context-panel {
  background: rgba(102, 126, 234, 0.05);
  border: 1px solid rgba(102, 126, 234, 0.2);
  border-radius: var(--ai-border-radius);
  padding: 12px 16px;
  margin: 8px 0;
  font-size: 13px;
}

.ai-context-panel .context-title {
  font-weight: 600;
  color: var(--ai-primary);
  margin-bottom: 4px;
}

/* Responsive Layout */
@media (max-width: 768px) {
  .ai-message-bubble {
    max-width: 90%;
  }
  
  .semantic-search-modal {
    min-width: 100%;
    width: 100%;
  }
}

/* Scrollbar Styling */
.ai-chat-notes-root ::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.ai-chat-notes-root ::-webkit-scrollbar-track {
  background: transparent;
}

.ai-chat-notes-root ::-webkit-scrollbar-thumb {
  background: rgba(102, 126, 234, 0.3);
  border-radius: 3px;
}

.ai-chat-notes-root ::-webkit-scrollbar-thumb:hover {
  background: rgba(102, 126, 234, 0.5);
}
`;
/*! Bundled license information:

localforage/dist/localforage.js:
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)
*/
