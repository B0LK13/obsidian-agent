/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ai-client.ts
var ai_client_exports = {};
__export(ai_client_exports, {
  LocalAIClient: () => LocalAIClient
});
var LocalAIClient;
var init_ai_client = __esm({
  "src/ai-client.ts"() {
    LocalAIClient = class {
      constructor(settings) {
        this.settings = settings;
        this.validateEndpoints();
      }
      /**
       * Validate that all endpoints are localhost
       * This enforces the local-only security requirement
       */
      validateEndpoints() {
        const endpoints = [
          { name: "LLM", url: this.settings.llmEndpoint },
          { name: "Embeddings", url: this.settings.embedEndpoint },
          { name: "Vector DB", url: this.settings.vectorEndpoint }
        ];
        for (const endpoint of endpoints) {
          const url = new URL(endpoint.url);
          if (url.hostname !== "127.0.0.1" && url.hostname !== "localhost" && url.hostname !== "::1") {
            throw new Error(
              `Security violation: ${endpoint.name} endpoint must be localhost. Got: ${endpoint.url}. External connections are blocked.`
            );
          }
        }
      }
      /**
       * Create an abort controller with timeout
       */
      createTimeoutSignal(ms) {
        const controller = new AbortController();
        setTimeout(() => controller.abort(), ms);
        return controller.signal;
      }
      /**
       * Check health of all AI services
       */
      async checkHealth() {
        const status = {
          llm: false,
          embeddings: false,
          vector: false
        };
        try {
          const llmResponse = await fetch(`${this.settings.llmEndpoint}/health`, {
            method: "GET",
            signal: this.createTimeoutSignal(5e3)
          });
          status.llm = llmResponse.ok;
        } catch (e) {
          status.llm = false;
        }
        try {
          const embedResponse = await fetch(`${this.settings.embedEndpoint}/health`, {
            method: "GET",
            signal: this.createTimeoutSignal(5e3)
          });
          status.embeddings = embedResponse.ok;
        } catch (e) {
          status.embeddings = false;
        }
        try {
          const vectorResponse = await fetch(`${this.settings.vectorEndpoint}/health`, {
            method: "GET",
            signal: this.createTimeoutSignal(5e3)
          });
          status.vector = vectorResponse.ok;
        } catch (e) {
          status.vector = false;
        }
        return status;
      }
      /**
       * Send chat completion request to local LLM
       */
      async chat(prompt, context) {
        var _a, _b;
        const messages = [];
        if (context) {
          messages.push({
            role: "system",
            content: `You are a helpful AI assistant with access to the user's knowledge base. Context: ${context}`
          });
        }
        messages.push({
          role: "user",
          content: prompt
        });
        const request = {
          model: this.settings.defaultModel,
          messages,
          temperature: 0.7,
          max_tokens: 2048,
          stream: false
        };
        try {
          const response = await fetch(`${this.settings.llmEndpoint}/v1/chat/completions`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(request),
            signal: this.createTimeoutSignal(6e4)
            // 60 second timeout
          });
          if (!response.ok) {
            const error = await response.text();
            throw new Error(`LLM request failed: ${error}`);
          }
          const data = await response.json();
          return ((_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) || "No response from AI";
        } catch (error) {
          console.error("AI chat error:", error);
          return `Error: ${error.message}. Make sure the local AI stack is running.`;
        }
      }
      /**
       * Generate embeddings for text
       */
      async embed(text) {
        var _a;
        try {
          const response = await fetch(`${this.settings.embedEndpoint}/embed`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ input: text }),
            signal: this.createTimeoutSignal(1e4)
          });
          if (!response.ok) {
            throw new Error(`Embedding request failed: ${await response.text()}`);
          }
          const data = await response.json();
          return ((_a = data.data[0]) == null ? void 0 : _a.embedding) || [];
        } catch (error) {
          console.error("Embedding error:", error);
          throw error;
        }
      }
      /**
       * Query the vector database
       */
      async queryVectorDB(embedding, nResults = 5) {
        try {
          const response = await fetch(`${this.settings.vectorEndpoint}/query`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              embedding,
              n_results: nResults
            }),
            signal: this.createTimeoutSignal(1e4)
          });
          if (!response.ok) {
            throw new Error(`Vector query failed: ${await response.text()}`);
          }
          const data = await response.json();
          return data.results || [];
        } catch (error) {
          console.error("Vector DB error:", error);
          return [];
        }
      }
      /**
       * Add documents to vector database
       */
      async addToVectorDB(documents) {
        try {
          const response = await fetch(`${this.settings.vectorEndpoint}/add`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ documents }),
            signal: this.createTimeoutSignal(3e4)
          });
          if (!response.ok) {
            throw new Error(`Add to vector DB failed: ${await response.text()}`);
          }
        } catch (error) {
          console.error("Add to vector DB error:", error);
          throw error;
        }
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianAIAgent
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
init_ai_client();

// src/rag-service.ts
var import_obsidian = require("obsidian");
var RAGService = class {
  constructor(app, settings) {
    this.isIndexing = false;
    this.indexedCount = 0;
    this.app = app;
    this.settings = settings;
  }
  /**
   * Index all markdown files in the vault
   */
  async indexVault() {
    if (this.isIndexing) {
      throw new Error("Indexing already in progress");
    }
    this.isIndexing = true;
    this.indexedCount = 0;
    try {
      const files = this.app.vault.getMarkdownFiles();
      const batchSize = 10;
      for (let i = 0; i < files.length; i += batchSize) {
        const batch = files.slice(i, i + batchSize);
        await this.indexBatch(batch);
        console.log(`Indexed ${this.indexedCount}/${files.length} files`);
      }
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Index a batch of files
   */
  async indexBatch(files) {
    const documents = [];
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        const embedding = await this.getEmbedding(content);
        documents.push({
          id: file.path,
          content: content.substring(0, 5e3),
          // Limit content size
          metadata: {
            path: file.path,
            title: file.basename,
            mtime: file.stat.mtime
          },
          embedding
        });
        this.indexedCount++;
      } catch (error) {
        console.error(`Failed to index ${file.path}:`, error);
      }
    }
    if (documents.length > 0) {
      const { LocalAIClient: LocalAIClient2 } = await Promise.resolve().then(() => (init_ai_client(), ai_client_exports));
      const client = new LocalAIClient2(this.settings);
      await client.addToVectorDB(documents);
    }
  }
  /**
   * Index a single file
   */
  async indexFile(file) {
    try {
      const content = await this.app.vault.read(file);
      const embedding = await this.getEmbedding(content);
      const { LocalAIClient: LocalAIClient2 } = await Promise.resolve().then(() => (init_ai_client(), ai_client_exports));
      const client = new LocalAIClient2(this.settings);
      await client.addToVectorDB([{
        id: file.path,
        content: content.substring(0, 5e3),
        metadata: {
          path: file.path,
          title: file.basename,
          mtime: file.stat.mtime
        },
        embedding
      }]);
    } catch (error) {
      console.error(`Failed to index ${file.path}:`, error);
      throw error;
    }
  }
  /**
   * Get embedding for text
   */
  async getEmbedding(text) {
    const { LocalAIClient: LocalAIClient2 } = await Promise.resolve().then(() => (init_ai_client(), ai_client_exports));
    const client = new LocalAIClient2(this.settings);
    return await client.embed(text);
  }
  /**
   * Get relevant context for a query
   */
  async getRelevantContext(query, nResults = 5) {
    try {
      const embedding = await this.getEmbedding(query);
      const { LocalAIClient: LocalAIClient2 } = await Promise.resolve().then(() => (init_ai_client(), ai_client_exports));
      const client = new LocalAIClient2(this.settings);
      const results = await client.queryVectorDB(embedding, nResults);
      const contextParts = results.map((result) => {
        var _a, _b;
        return `Note: ${((_a = result.metadata) == null ? void 0 : _a.title) || result.id}
${((_b = result.content) == null ? void 0 : _b.substring(0, 1e3)) || ""}`;
      });
      return contextParts.join("\n\n---\n\n");
    } catch (error) {
      console.error("Failed to get relevant context:", error);
      return "";
    }
  }
  /**
   * Find related notes
   */
  async findRelatedNotes(content, nResults = 5) {
    try {
      const embedding = await this.getEmbedding(content);
      const { LocalAIClient: LocalAIClient2 } = await Promise.resolve().then(() => (init_ai_client(), ai_client_exports));
      const client = new LocalAIClient2(this.settings);
      const results = await client.queryVectorDB(embedding, nResults);
      const files = [];
      for (const result of results) {
        const file = this.app.vault.getAbstractFileByPath(result.id);
        if (file instanceof import_obsidian.TFile) {
          files.push(file);
        }
      }
      return files;
    } catch (error) {
      console.error("Failed to find related notes:", error);
      return [];
    }
  }
  /**
   * Search notes by semantic similarity
   */
  async semanticSearch(query, nResults = 10) {
    try {
      const embedding = await this.getEmbedding(query);
      const { LocalAIClient: LocalAIClient2 } = await Promise.resolve().then(() => (init_ai_client(), ai_client_exports));
      const client = new LocalAIClient2(this.settings);
      const results = await client.queryVectorDB(embedding, nResults);
      const matches = [];
      for (const result of results) {
        const file = this.app.vault.getAbstractFileByPath(result.id);
        if (file instanceof import_obsidian.TFile) {
          matches.push({
            file,
            score: 1 - (result.distance || 0)
            // Convert distance to similarity
          });
        }
      }
      return matches;
    } catch (error) {
      console.error("Semantic search failed:", error);
      return [];
    }
  }
};

// src/canvas-integration.ts
var import_obsidian2 = require("obsidian");
var CanvasIntegration = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Create a new canvas file
   */
  async createCanvas(name, data) {
    const canvasContent = JSON.stringify(data, null, 2);
    const filePath = `Canvas/${name}.canvas`;
    const canvasFolder = this.app.vault.getAbstractFileByPath("Canvas");
    if (!canvasFolder) {
      await this.app.vault.createFolder("Canvas");
    }
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(existingFile, canvasContent);
      return existingFile;
    }
    return await this.app.vault.create(filePath, canvasContent);
  }
  /**
   * Create a canvas from a set of notes
   */
  async createCanvasFromNotes(title, files) {
    const nodes = [];
    const edges = [];
    const centerX = 0;
    const centerY = 0;
    if (files.length > 0) {
      const centerFile = files[0];
      nodes.push({
        id: "center",
        type: "file",
        x: centerX,
        y: centerY,
        width: 400,
        height: 300,
        file: centerFile.path
      });
    }
    const radius = 600;
    const angleStep = 2 * Math.PI / Math.max(files.length - 1, 1);
    for (let i = 1; i < files.length; i++) {
      const file = files[i];
      const angle = (i - 1) * angleStep;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      const nodeId = `node-${i}`;
      nodes.push({
        id: nodeId,
        type: "file",
        x,
        y,
        width: 300,
        height: 200,
        file: file.path
      });
      edges.push({
        id: `edge-${i}`,
        fromNode: "center",
        toNode: nodeId,
        label: "related"
      });
    }
    return await this.createCanvas(title, { nodes, edges });
  }
  /**
   * Create a canvas from AI-generated structure
   */
  async createCanvasFromAI(title, structure) {
    const nodes = [];
    const edges = [];
    if (structure.nodes) {
      for (const node of structure.nodes) {
        nodes.push({
          id: node.id,
          type: node.type || "text",
          x: node.x || 0,
          y: node.y || 0,
          width: node.width || 400,
          height: node.height || 300,
          content: node.content,
          file: node.file
        });
      }
    }
    if (structure.edges) {
      for (const edge of structure.edges) {
        edges.push({
          id: edge.id,
          fromNode: edge.from,
          toNode: edge.to,
          label: edge.label
        });
      }
    }
    return await this.createCanvas(title, { nodes, edges });
  }
  /**
   * Add a node to an existing canvas
   */
  async addNodeToCanvas(canvasFile, node) {
    const content = await this.app.vault.read(canvasFile);
    const data = JSON.parse(content);
    data.nodes.push(node);
    await this.app.vault.modify(canvasFile, JSON.stringify(data, null, 2));
  }
  /**
   * Generate a mind map canvas from content
   */
  async generateMindMap(title, centralTopic, subtopics) {
    const nodes = [];
    const edges = [];
    nodes.push({
      id: "center",
      type: "text",
      x: 0,
      y: 0,
      width: 300,
      height: 150,
      content: centralTopic
    });
    const radius = 500;
    const angleStep = 2 * Math.PI / subtopics.length;
    subtopics.forEach((topic, index) => {
      const angle = index * angleStep;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      const nodeId = `subtopic-${index}`;
      nodes.push({
        id: nodeId,
        type: "text",
        x,
        y,
        width: 250,
        height: 120,
        content: topic
      });
      edges.push({
        id: `edge-${index}`,
        fromNode: "center",
        toNode: nodeId
      });
    });
    return await this.createCanvas(`${title}-mindmap`, { nodes, edges });
  }
};

// src/dataview-integration.ts
var DataviewIntegration = class {
  constructor(app) {
    this.dataviewAPI = null;
    this.app = app;
    this.initializeDataview();
  }
  /**
   * Try to get the Dataview API
   */
  initializeDataview() {
    const dataview = this.app.plugins.plugins["dataview"];
    if (dataview == null ? void 0 : dataview.api) {
      this.dataviewAPI = dataview.api;
      console.log("Dataview integration initialized");
    } else {
      console.log("Dataview plugin not found or not ready");
    }
  }
  /**
   * Check if Dataview is available
   */
  isDataviewAvailable() {
    return this.dataviewAPI !== null;
  }
  /**
   * Execute a Dataview DQL query
   */
  async queryDQL(query) {
    if (!this.dataviewAPI) {
      throw new Error("Dataview is not available");
    }
    try {
      const result = await this.dataviewAPI.query(query);
      return result;
    } catch (error) {
      console.error("Dataview query failed:", error);
      throw error;
    }
  }
  /**
   * Get all notes with specific tags
   */
  async getNotesByTag(tag) {
    const query = `LIST FROM #${tag}`;
    const result = await this.queryDQL(query);
    const files = [];
    return files;
  }
  /**
   * Get tasks from notes
   */
  async getTasks(filter) {
    let query = "TASK";
    if (filter) {
      query += ` WHERE ${filter}`;
    }
    const result = await this.queryDQL(query);
    return result.values || [];
  }
  /**
   * Get notes created in a date range
   */
  async getNotesByDateRange(startDate, endDate) {
    const query = `
            TABLE file.mtime
            WHERE file.ctime >= date("${startDate.toISOString().split("T")[0]}")
            AND file.ctime <= date("${endDate.toISOString().split("T")[0]}")
        `;
    const result = await this.queryDQL(query);
    return result.values || [];
  }
  /**
   * Generate a Dataview query for AI context
   */
  generateQueryForContext(topic) {
    return `
            TABLE file.mtime as Modified, file.tags as Tags
            WHERE contains(file.path, "${topic}")
               OR contains(file.tags, "${topic}")
            SORT file.mtime DESC
            LIMIT 10
        `;
  }
  /**
   * Get recent notes
   */
  async getRecentNotes(limit = 10) {
    const query = `
            TABLE file.mtime as Modified
            SORT file.mtime DESC
            LIMIT ${limit}
        `;
    const result = await this.queryDQL(query);
    return result.values || [];
  }
  /**
   * Get backlinks for a file
   */
  async getBacklinks(file) {
    const query = `
            LIST
            FROM [[${file.basename}]]
        `;
    const result = await this.queryDQL(query);
    return result.values || [];
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  llmEndpoint: "http://127.0.0.1:8000",
  embedEndpoint: "http://127.0.0.1:8001",
  vectorEndpoint: "http://127.0.0.1:8002",
  autoIndex: true,
  indexOnStartup: false,
  maxContextLength: 4096,
  defaultModel: "local-llm"
};
var ObsidianAIAgent = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.aiClient = new LocalAIClient(this.settings);
    this.ragService = new RAGService(this.app, this.settings);
    this.canvasIntegration = new CanvasIntegration(this.app);
    this.dataviewIntegration = new DataviewIntegration(this.app);
    this.addRibbonIcon("bot", "AI Agent", () => {
      this.openAIChatView();
    });
    this.addCommand({
      id: "open-ai-chat",
      name: "Open AI Chat",
      callback: () => this.openAIChatView()
    });
    this.addCommand({
      id: "index-vault",
      name: "Index Vault for RAG",
      callback: () => this.indexVault()
    });
    this.addCommand({
      id: "ask-ai-about-note",
      name: "Ask AI about current note",
      editorCallback: (editor, view) => {
        const content = editor.getValue();
        this.askAIAboutContent(content);
      }
    });
    this.addCommand({
      id: "generate-canvas-from-notes",
      name: "Generate Canvas from selected notes",
      callback: () => this.generateCanvas()
    });
    this.addCommand({
      id: "search-with-ai",
      name: "Semantic search with AI",
      callback: () => this.semanticSearch()
    });
    this.addSettingTab(new ObsidianAIAgentSettingTab(this.app, this));
    this.checkConnection();
    if (this.settings.indexOnStartup) {
      this.indexVault();
    }
    console.log("Obsidian AI Agent loaded");
  }
  onunload() {
    console.log("Obsidian AI Agent unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async checkConnection() {
    const status = await this.aiClient.checkHealth();
    if (status.llm && status.embeddings && status.vector) {
      new import_obsidian3.Notice("AI Agent: Connected to local AI stack");
    } else {
      new import_obsidian3.Notice("AI Agent: Cannot connect to local AI stack. Run: ./start-local-ai-stack.ps1");
    }
  }
  async openAIChatView() {
    const leaf = this.app.workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: "ai-chat-view",
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
  async indexVault() {
    new import_obsidian3.Notice("AI Agent: Starting vault indexing...");
    try {
      await this.ragService.indexVault();
      new import_obsidian3.Notice("AI Agent: Vault indexing complete");
    } catch (error) {
      new import_obsidian3.Notice(`AI Agent: Indexing failed - ${error.message}`);
    }
  }
  async askAIAboutContent(content) {
    const context = await this.ragService.getRelevantContext(content);
    const prompt = `Based on the following context from my knowledge base, please analyze and provide insights:

Context:
${context}

Current Note:
${content}

Please provide a thoughtful analysis.`;
    const response = await this.aiClient.chat(prompt);
    this.displayResponse(response);
  }
  async generateCanvas() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice("Please open a note first");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const title = activeFile.basename;
    const related = await this.ragService.findRelatedNotes(content, 5);
    await this.canvasIntegration.createCanvasFromNotes(title, [activeFile, ...related]);
    new import_obsidian3.Notice("AI Agent: Canvas created");
  }
  async semanticSearch() {
    new import_obsidian3.Notice("AI Agent: Semantic search - use the chat view");
    this.openAIChatView();
  }
  displayResponse(response) {
    var _a;
    const modal = document.createElement("div");
    modal.addClass("ai-response-modal");
    modal.innerHTML = `
            <div class="ai-response-content">
                <h3>AI Response</h3>
                <div class="ai-response-text">${response}</div>
                <button class="ai-response-close">Close</button>
            </div>
        `;
    document.body.appendChild(modal);
    (_a = modal.querySelector(".ai-response-close")) == null ? void 0 : _a.addEventListener("click", () => {
      modal.remove();
    });
  }
};
var ObsidianAIAgentSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Obsidian AI Agent Settings" });
    containerEl.createEl("h3", { text: "Local AI Stack Connection" });
    new import_obsidian3.Setting(containerEl).setName("LLM Endpoint").setDesc("URL for the local LLM server (must be 127.0.0.1 or localhost)").addText((text) => text.setPlaceholder("http://127.0.0.1:8000").setValue(this.plugin.settings.llmEndpoint).onChange(async (value) => {
      this.plugin.settings.llmEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Embeddings Endpoint").setDesc("URL for the local embeddings server").addText((text) => text.setPlaceholder("http://127.0.0.1:8001").setValue(this.plugin.settings.embedEndpoint).onChange(async (value) => {
      this.plugin.settings.embedEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Vector DB Endpoint").setDesc("URL for the local vector database").addText((text) => text.setPlaceholder("http://127.0.0.1:8002").setValue(this.plugin.settings.vectorEndpoint).onChange(async (value) => {
      this.plugin.settings.vectorEndpoint = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Indexing Settings" });
    new import_obsidian3.Setting(containerEl).setName("Auto-index on save").setDesc("Automatically index notes when they are saved").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoIndex).onChange(async (value) => {
      this.plugin.settings.autoIndex = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Index on startup").setDesc("Index the vault when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.indexOnStartup).onChange(async (value) => {
      this.plugin.settings.indexOnStartup = value;
      await this.plugin.saveSettings();
    }));
    const securityDiv = containerEl.createEl("div", { cls: "ai-agent-security-notice" });
    securityDiv.createEl("h3", { text: "Security Notice" });
    securityDiv.createEl("p", {
      text: "This plugin is configured for LOCAL-ONLY operation. All AI services must be running on 127.0.0.1 (localhost). External connections are blocked by design."
    });
  }
};
